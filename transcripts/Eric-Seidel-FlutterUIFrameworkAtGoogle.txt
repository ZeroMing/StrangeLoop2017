    "Flutter: How We're Building a UI Framework for Tomorrow at Google"
    by Eric Seidel
    
    So my name is Eric Seidel and I'm here today to talk to you about Flutter. Before we get to that, since most of you probably don't know me. I should give you a tiny bit of background about me. I've been a software engineer for heh-heh-heh going on 15 years now. Mostly worked on the web and browsers, worked on both Safari and Chrome, etc. About three years ago I helped found the Flutter team which is what I now manage and what we're going to talk about today. So Flutter, if you haven't heard of us, our goal is to make it easier and faster for you to get to iOS and Android. In fact, our mission is to help build the best way to develop for mobile. And you may ask why. There are a few rough edges and in fact we spent a lot of time at the beginning of this project talking to other teams who work on mobile and understanding their concerns and we heard a lot of the same things and maybe these will resonate with you. We heard that getting to mobile can be slow and expensive. We heard that doing delightful things on mobile can be hard and that the platform diversity story of current mobile complicates this and finally if you really want to reach all users, at least in the US market, you have to develop for multiple platforms. And that can mean two or three teams. So we said to ourselves in doing this, there must be a better way. That development should be fast. I mean here it is, we've in 2017, custom should be easy. You should be able to trust that what you saw on your phone while developing is what your users see. And finally, that you should ideally be able to build things once and take that hard work to more than one place. So let me show you a taste of what we've built. So I'm going to switch over. I have an Android and an iOS phone. I'm going to switch over to the iOS one here. I'm going to launch one of our little demo apps. And the first thing you'll notice. Maybe it wept by too fast. But of course it just flies open, scrolls beautifully, hits every frame, there's lots of pretty little demos, lots of animations. Etc.
    But I can also show you this, same app on Android, if I switch over. Here's an Android phone, same story. Boots up beautifully, scrolls beautifully, you'll notice that this now looks more like Android, different scroll behavior, different title alignment, different back behavior, etc.
    So these just look like iOS and Android apps and they are just iOS and Android apps, but what you may not know is that Flutter is painting every single thing on the screen. So I'm Android here, I go into our little debug menu and I turn to iOS and so now when I scroll I get different physics, I get a bounce behavior and when I go in, so this is for example an iOS-style control, and I have a back gesture. All because we control every single pixel, every single gesture and we're going to talk a lot more about how we do that, but that was a taste. So let's go back to our slides.
    So again, our goals, here we are in 2017, we want to build something beautiful, something fast. Let's talk about how we went about doing it. So we thought about these goals and what problems we were going to solve in the mobile space and we found some alliteration, maybe a thesaurus and I wanted to talk about, particularly because this is a tech conference, the tech that we built to solve these problems.
    So, let's start with fluid. Why do you care about fluid? We wanted to build a fluid developer experience. We want to keep you in flow, we want to get you home early. This is the thing that most personally excites me about this project. I also like locking around at my colleagues and thinking about the hours of their day that I helped save, that I gave back to them. Because I have plenty of things in my life that distract me out of flow. I feel like fighting my tool chain should not be one of them. As so elegantly expressed in this comic.
    So let's talk about the tech. What did we build? Well, the first big part is that at a very low level of our system, we built in a technology that we called hot reload. You've seen our text with a similar name, I believe ours is a little different. Let's talk about that. We talked to teams inside Google who had 10s of minutes on dev cycles waiting for X you were to turn and then you scroll around and fiddle around in the screen and known you find the bug and you blindly try and fix it and blindly return to the cycle. And so I can show you this is our actual dev cycle, our actual time between code and device inside Flutter and you can see in this GIF I'm changing the color and hit save and it's immediately reflecting on the device. Similarly I'm changing the logic of my app and again, it immediately reflects on the device. This is very powerful, saves you a lot of time. And also I should say, this is because we built it so low level into our system, we built the rest of the system around, this really works. This is the default way that you do development and we test and we record stats from the wild. It's fast, we know that it works. We know that people use it. In any case, there's a lot of very interesting technical details, which -- we could spend an hour talking about. But here's a taste and therefore several YouTubes on this topic that you can watch and learn a ton about how this works. How we make that magic happen.
    So one of the lessons that I learned in doing this is how much language and tool chain matter. If you're trying to accelerate developers and so we started out in one language and actually built two full copies of our system before switching.
    This is something I'd never done before. Here we were, a year into our project happened we were switching languages. We started out actually with JavaScript. It didn't in the end work for us, and so we switched, and we went on an exhaustive search, tried lots of languages, basically anything we could bring to mobile and ended up with one that I didn't expect but it has turned out to work very well. That language you may not have heard of because it's kind of small. It's called Dart, this is a language in heavy use inside Google. It's one of the accelerated growth ages right now. It's used to build really big things for Google. We didn't really care about that except we knew it was battle hard and it could scale. And ooh then finally this team cared a lot about productivity and they had seen a lot of productivity gains in the web platform which is where they were currently targeting and we ended up really liking this decision. It took us a while to get there but there are some really neat things that this language does that I haven't always seen elsewhere. For example this one. This language both has a fast development cycle which you've seen, but also when it's time to ship, compiles straight to RM code. Also as an optional but strong typing system, which again, those million-line apps eleven leverage heavily.
    It has generational garbage collection. Which basically means fast we do lots of tiny tiny allocations and they're very cheap to make, very cheap to let go of and finally we found it familiar, easy to learn. If you've used JavaScript this will feel totally natural to you.
    The final thing that I learned through this process was how important tools were. We have spent tons of time building tools. If you want to accelerate developers, you have to invest in tools and we have done that.
    So I want to show you what this workflow actually looks like. So I'm going to pop out of this into an editor. So Flutter supports a variety of editors. This is a bit like a cooking show. I already followed the template and did a create, but this is about two minutes into the process. We just didn't have to wait for Xcode to spin up for the first time. Here I have this little counter. Again it works on iOS or Android. I happen to be using the iOS simulator, but you can use whatever. I want to show you again that dev cycle so if we change that to red I just save and boom. If I go and I say, want to change this text, right, because that button is actually a fab, a floating action button, there again, it appears right away, same thing, I could add some text. Say things like hi Strange Loop, and there you go. In any case, this is the dev cycle this is what you live in, this is what you do, keeps you in flow all day long and we'll show more of this in a bit.
    Let's go back and talk a bit more.
    So our second goal, second thing that we wanted to solve, was that we wanted to produce a system that was flexible. So that developers never had to say no to their designers, this was in part due to direct requests from these teams that we worked with earlier and part to us just watching the market and seeing what was happening. Gone are the days of yore where you just produce a cookie cutter check boxes and buttons app. Now we can do brand-forward design. And similarly we also learned through this is that even teams that told us inside Google that no we're just going to do material design, we're just going to follow the spec, would still do custom things perhaps without thinking of it. So there are at least three things that are violations of the material design spec in this screenshot that were very easy for the team to create because they had tools and matched what their designer wanted. So, another thing that we learned or how we went about doing this, how we created a flexible system, was layers, lots and lots and lots of layers. So this again came from direct developer feedback as we were starting this project and one of the developers put it that they felt like dealing with some of these systems that they were dealing with the iceberg. That they had this little tiny service that they were allowed to use and they knew that there were big powerful things buried under the ocean. They could see them but they couldn't touch and so we wanted to build a system that in a sense flipped the iceberg and put all the good stuff up under your control, in the same language that you're writing in so you can jump to definition all the way down, you can edit it, etc. and so I'm going to talk about some of these layers that we built.
    This is an extremely simplified layering diagram we have lots of layers, but we're going to talk about it.
    Starting at the bottom, this is the run time API. This basically gives you a canvas, some accessibility hooks, a way to lay out text, some networking APIs, and that's about it. You can write in this layer, but you certainly can if you want to.
    On top of that we have a rendering layer which should be very familiar to someone who's worked in UI programming before. This is a stateful view model, very typical way. The job of this layer is to do caching, let you put a box on the screen, let you move it around, to do layouts, composites, that kind of thing. One of the drawbacks of working at this layer and is typical of other view systems, is that there are some complexities a problem is this stateful view model has has a state problem. So those can get out of synch and cause all kinds of bugs. We chose to build a widgets layer that handles composition for us. Everything at the rendering layer tends to have a widget, as well, but widgets are how you compose those. Our widgets layer is very React-inspired. These are immutable widgets, short-lived ephemeral objects and it's much shorter to compose at this layer. It also has a very simple data flow. You just always create new widgets, you don't have to worry about creating them.
    And then layers of opinion. We have several of these. A set of iOS widgets which you saw a little of called Cupertino. And so let's go back and talk about some of the technical changes, technical innovations we made at these layers to do this kind of flexibility, to do the kind of speed that we wanted.
    So one is rendering, to understand rendering, you have to know a little bit about our pipeline. Starting at the V synch or user input and ending when we push pixels to the GPU. The part that I want to talk about starts at this rendering layer. Painting and compositing. And one of the things that we learned in working in this is that simple can be fast. If you start with simple, which will understood algorithms, or algorithms with well understood properties, you can build simple things and take advantage of those properties to go fast.
    So let's talk about, for example, how we do layout and painting. It's typical in other systems to sometimes join layout and painting into a single paint phase or it's typical in layout to have a multipass layout where a single view will walk all of its children to gather some information and walk them all again to lay them out. This is in contrast to how things were done in Flutter where we intentionally do layout in paint and do a simple pass through. And this allows us to scale to much deeper trees than you might be used to in other widgeting systems.
    Another way in which we found simple is fast is that we found that with very simple constraints, you can generate expressive layouts, so basically everything you've seen is done through a very, very simple constraint model of just basically min, max, width and height. This is in contrast to you. And then it has a general purpose constraint solver to solve that and we found we have something very simple and fast instead. Another way we did things here is typically how you did repainting is you direct the dirty rects and you repaint based on that. And we found it was simpler and faster to invalidate subtrees. We could take advantage of this to go fast. This was actually a big speed win for us. I want to talk a little bit more about more innovations, this time at the widgets layer. So one of the things that we did differently here, I don't know of any other React-still system where both the React layer and the view layer are built by the same time. But before we talk more about widgets, you should know again a little bit of history, so I said I worked on the web for a better part of a decade. When we started Flutter, I was still sitting with the Chrome team at Google. I was still steeped in the web world. There was an effort at the time and there was a bunch of different documents to convince standards organizations to focus on explaining the web platform, rather than bolting on more features and this is something that we really took to heart in building our system, and maybe to the extreme.
     It is very typical in these systems to have these sort of container objects that have lots of little properties that you set when you want to build pup. So you know, like difference are this way. Than when you want to build up a complicated UI. In our system, we -- our -- or sorry, our container class if you look at it it's this set of if statements. Where we wrap the subtree in another little simple widget and a perhaps crazy example of that, I don't know of any other system that has one of these is that we have this very simple padding widget. None of the other sure, you can build your own widget and wrap in padding, but you build other widgets commonly out of these other little widgets. And this composition is all over the system. So here again in our animation system we have -- the animation system is built of lots and lots of little pieces that again you can replace and you can add to. There's no locked box here. There's no like fancy animation system that would be amazing if you could just specify your own curves. You you produce a series of doubles, you then might connect to a series of curves and then you can change those to tweens, and produce a stream of whatever. Rects or colors or whatever. The so flexibility. Let's talk flexibility. I want to just show you a live example. Here very briefly if I switch back to my iPhone.
    I can just show you an in-production app that takes advantage of this. So this for example is an app built with Flutter, shipped and doesn't really quite look like iOS, doesn't really quite look like Android. But rather is their own different look and feel and this is them taking advantage of this flexibility to build what they wanted to build.
    So let's go back and show you some of this composition. So if we continue with the hi, Strange Loop and again, we never lost state. We still have our number 7 in the corner, we can build more complicated things using this composition. So say for example I sent this to my designer, I'm ready to ship my counter and my designer was oh, I want a different floating action button that is more styled in the way we do things. I want an explosion or things like that. We can build of course our own floating action button. There's no secret. We can jump to definition and read the code but you'll find it's very simple. You can just keep going. Jump, jump, jump, because all the code is written up in your layer of the system. But we can also make our own. So we can make this my Fab. I want to use my fancy editor to split out a widget. There are more talks on YouTube that it explain all of this to your desire. I'm going to type it out. Actually, I wanted a stateless widget, MyFab, oops, boom, we crashed our little app, it's telling us that we have actually not invalided a structure for this, but we could have seen this before because we could have looked at our live analysis, but we can just fix that it's very easy. We can do a MyFab, stateless widget, void callback for on pressed, and we'll do a final widget for child. Now we send this sucker. Now we have another bug. Aha, what did it say? So we'll fix that. We'll send it again. And there we go. So I'm back, I never lost state, went all the way through that error, I never stepped out of flow. But we're not drawing anything and that's because if we look at our build method we're just taking our empty container, so we take this container at our child that we passed in. And now milliseconds later, we're drawing something on screen, we have our little icon, so now we could say, wrap this again, I'm using my fancy editor, in a new widget, because when we think of this budding, we want it to float, right? So the way you float things in the material side of the world is you make a material, and we'll tell this thing to reformat, if I can remember the keystrokes. Whoops. OK. We'll -- we're going to go ahead and add an elevation to this. Elevation, we'll make it, I don't know, 12 sounds like a good number and we'll give it a color, because our designer told us that they want FAB to be green, so we'll do colors, green, and we'll send to device and now we have our little FAB with a shadow and it's green, but we could keep going. I'll just reformat it so it's easier to read. For one, this FAB doesn't really handle presses so the way we do that in a material world is we add an ink well which is something that knows how to -- I'll use my fancy editor again, inkwell, we have a child and the inkwell also knows how to handle our on press. So we'll do our on tap and pass our on pressed. I know this feels a little magical because I have to do this so quickly to fit into your time, but now we have -- you can see we've done very, very little typing. We are up to all of ten lines and we now have a functioning button and we can complete this by giving our container the desired width and height and I think, you know, I can send that again, and it immediately changes. And we go back to our material. And we're going to make this a circle.
    Because I think that our designer didn't want a square button, right? That's it. We're done. In all of whatever that was, two minutes. And ten lines of code, we have built -- we have rebuilt some core control, that we can now customize to our heart's content. This is just how the system works. This is how composition works in our system.
    So let's go back to the slides.
    I hope you guys are as excited as I am about working in systems like this. I like when the machine does what I tell it to.
    So the final thing that I want to talk about, the final part that we wanted to build, was something that was faithful. Something that you could trust would deliver the designs that you worked hard on implementing on your phone, to all the phones of your users.
    And so I want to talk about -- well, I guess we should start by why, why you care about this. Again, these came from these early discussions where we were talking with all of these teams and they talked about things that their apps would break, that they would have to fight with hardware differences that would cause their apps to look weird sometimes, but they also had frustrations about waiting for their users to update. That they wanted to push a fancy design or something, but they couldn't push that until enough of their users had updated. You see this is a phone from 2012, two years before material design ever existed, that is running material design via Flutter and you could imagine doing your designs and having that level of control and pushing to all of your users now. And so the insight, the tech as to how we got there was to go to the Metal. This is something we realized relatively early on, that we needed to build our own run time but we didn't want to reinvent the wheel and so we actually spent a lot of time on this, searching far and wide, for systems that had already been battle-hardened, so we took some graphics, part of the graphics stack out of Chrome, we extracted a bunch of tech out of Android and as we mentioned before we took a language that had been successful on the web and we brought it to mobile. And I should talk very briefly about some of the changes that we made to these systems, because we didn't just take them as they were, but for example, for Skia, which is our 2D library, we worked with this team to add color correction, so for example when you're shipping to really old phones you can trust that your images look right and similarly, we worked on adding a text library on top.
    And one note, sort of a thing that fell out of having built our own run time is that then we were faced with all this portability and it was kind of neat. Thankfully again, so much of the heavy lifting is done by these component parts that we salvaged from other products. For instance, Dart is our CPU and similarly Skia, but then our tests worked everywhere and our product worked everywhere. Now we're focused on iOS and Android today. We don't really talk about this today. But Flutter really goes all sorts of places I've seen it working on watches, I'm just waiting for somebody to send me a YouTube of somebody running on their refrigerator, because I'm sure it can work. Which is interesting and maybe we'll see that in the future.
    It's also important to match the expectations of your users, be faithful to their expectations on the platform that they're running on. And we spent a ton of time on this. We started by making our pixels match. And we actually found that our users didn't care about that. When we studied that. We cared so we still do it. But users, what they cared about was the feel. They cared about that when they tapped, that the targets were big enough, they cared about when they moved and they scrolled that it felt the same way that the rest of their apps felt, that the gestures felt the same, and so we spent a ton of time on this. We built all sorts of interesting tools to make sure that we understood, let's say this one is for scrolling, that we could tell you exactly how many pixels our scroll velocity differs from the OEM controls for example.
    That's basically what I wanted to tell you. I hope that you enjoyed learning about the different problems that we're trying to solve. The tech that we use to go about solving them. I should talk very briefly before I go, I know this is a tech talk, but we could talk a little bit about product, which is that this is a very new product. We just released or announced to the public our alpha, in May of this year at Google io and since then we've seen an explosion of usage. We're already up to 100 apps, this brand new thing, this push to play. And again as you saw, we've seen some big brands already adopt us. One was launched last month, this was Hamilton featured on both stores, very well reviewed. Finally what I'm really here for, since this is again a tech conference is it that this is all open source, it's been open source since day one. I like working in that environment, but open source is all built on community and we do have a strong and growing community and I'm here to invite you. If this sort of stuff gets you out of bed in the morning, like it does me, you please should come check us out, again we have over 125 contributors to our main repository, and probably more than that if I counted all of them. Over 1,000 people in our gitter. This is a very active project and we would love to see you there. So thank you very much for your time and I will be around to answer questions and I have stickers to give out if you need them, so thanks.
    [applause]
