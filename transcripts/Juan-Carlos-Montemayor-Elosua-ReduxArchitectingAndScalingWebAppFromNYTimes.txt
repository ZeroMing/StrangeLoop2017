      "Redux: Architecting and scaling a new web app at The New York Times."
      By: Juan Carlos Montemayor Elosua.
      >> 10:10; right?  All right.  One more minute.
      Cool.  Okay.  I think we can get started while people are coming in.
      By the way, I made a Redux channel on Slack, and I posted the slides on there, so you could and download them if you want to follow along.  There's some code examples, but they don't fit with the really big font on the screen, so if you want them on your computer, you have them.
      Cool.  Okay.  Two minutes late.  So about me, I'm very puncture kidding, my name is Juan Carlos Montemayor Elosua, but most people know me as JC because it's a very long in my, I'm from Mexico, and I've been living in New York for the last four years.  I went to university to study computer science, and that's where I really found a passion for functional programming.  And so even though now that I'm working in Web, I try to be as functional as I can all the time.
      For the last four years, I've been working for The New York Times, I've been working for their -- it's changed names a couple of times.  It's basically their new products group.  So this product specializes in finding product opportunities, building out prototypes, and launching full products, and it's been really fun.  I work on an app called NYT Now for news.  An app called NYT Watching which we'll talk about today, and starting Monday, I'm transferring over to lead the iOS development for NYT Cooking.  So it's going to be a new adventure.
      And outside, I'm a big hobby person, so I'm an Opera singer, excuse my sore throat today.  I'm an Opera producer, so with a bunch of friends, we produce an Opera based on a doll's house and my latest hobby, I'm certified to be a wine, so if there's any people who like wine, please come talk to me after.  I talk about wine more than I do Redux, so --
      [Laughter]
      So before we get started on this talk, I just want to give you a tour of watching because I'm going to use a lot of real life examples, so it's not all just, like, Redux theory, it's, like, here are some problems, and here's how we solve them.
      So watching is based on a thing called a recommendation, so this recommendation isn't, like, an -- you know, machine learning, like, recommended.  It's just an editorial thing, so we write things based on movies or TV shows.  In this case, get out, and we can tell you the year it was released, who's in it, a short summary, and we tell you why you should watch it or maybe why you should skip it.  Sometimes things are really scary or specific triggers.  And we also tell you where to watch something, and that's going to come into play later in the talk.  So we can tell you, hey, this is available on iTunes for 4.99.
      You can save recommendations into a thing called a watch list, so it is like a save area.  And the important thing here that I'm going to keep referring to is cards.  So cards is one of those words that means a million different things at the Times.  In this specific case, there are literally UI elements called cards.  You can save them, you can like them, and you can click the dot, dot, dot button to see where you can stream them.
      We have a thing called a feed.  So in this feed, you can see some tags at the top, you can click them and browse through all of the recommendations, and there's posts, so you can read about the latest happenings in the media world.  And then the take away here is also here are the cards again, and they're, like, in a list, and we call that list a carousel, so I'm going to be referring to a carousel.  This is what I mean.  You can click them and slide over.
      I also mentioned the tags on top of the page, so you can click them to, like, search through our recommendation offerings.  In this case, we clicked on the strong female lead tag, you should definitely watch Glow if you haven't.  It's pretty great.  No one's paying me to say that.  I actually really love it.
      Cool.  So that's watching.  And as I mentioned before, I work in the new products area of the Times, and it's kind of stressful when you're making a new product.  So we work -- we have a VC model, so we -- what we have to do is pitch a committee an idea and, like, we can be, like, oh, we can do something with film and television, and we think we can get this many readers using it in a year.  Will you give us, like, X million dollars to build it out?  And we have to do that every couple months.
      So we first asked money to build it out, and once we build it out, we have to prove that we were successful, so we have to ask for more money.
      So before we start on Watching, the goal was to launch an MVP version in less than a year.  And as you can see the word MVP is under quotes because it was much more than MVP, was full product with saving and a lot of features.
      We also needed the ability to pivot and change features quickly because you learn things, you launch things, you see how your users react, and you have to change quickly because, again, you're on a timeline of a year or a couple of months to prove that your product is successful, or else they'll shut it down.
      We also needed to, like, keep growing quickly again.  Limited time, and you want to just make as many features as possible.
      And how many people here are Web developers?  Cool.  Any, like, non-Web developers?  Awesome.
      I mean, this is, like, the problem with all kinds of software, but, basically, you have a website, and you need data, so, like, this arrow represents us getting data from a cloud for a recommendation.  But there's more data, so we need to get the user from the cloud also.  And once we have the user, we can tell, like, the save component, hey, now you should check if anything saved or not in the cloud.  And oftentimes, we have your thing with multiple clouds, so just by looking at all the arrows here, you can tell it's -- I mean, you know because you program.  It gets messy really quickly and the more arrows you add to this diagram, the more headaches.
      So we're dealing with this, we're dealing with very strict product requirements that we need to grow quickly and show success, so we decided to use Redux to help us meet all of those goals, and that's what I'm going to talk to you about today.
      Before we get to the agenda, I always like to know who here is new to Redux.  Here to learn?  Awesome.  Who here think so they're intermediate in Redux?  And who here has been using Redux for a long, long time by which I mean two years because that's -- it's been around for two years or three.  Cool.  Great.  That's a good mix.
      Okay.  So first, we're going to talk about what unidirectional data is, which is the philosophy of Redux.  So I'm going to take you through the steps of your state, turning into views, dispatching actions to do stuff, and then having those action rebuttal come back into reducers, so that you can change your state, and we're going to see the whole flow.
      We're going to talk about how to separate data from views using containers.  This is going to give you some really nice separation of concerns.  We'll talk about more of that later.
      We're going to talk about simplifying data relationships with selectors.  So that's when you have a lot of data from a lot of different places, and you want your views to deal with simple objects, and also, it has really nice performance implications, so we'll talk about that.
      And then the last thing is we're going to talk about business logic.  I'm going to define it because it means different things in different places, and I'm going to tell you how we deal with those kinds of things.
      So let me take water because my mouth is very dry.
      Cool part one.  What is Redux?  So Redux is a predictable safe container for JavaScript applications.  That word is bolted.  It's going to come back throughout the talk.  Redux helps you manage your state or other -- like, your data.
      And it's also a nice way to organize your app and separate things really nicely.
      And the last point here, it's going to come back also in the talk, I always like to describe things in, like, a mathematical way.  This is Strange Loop.  I don't need to explain this, like, why do this, but let me explain this.  So, basically, this is how I look like at my app.  You have your UI, and then you give it your state, and it becomes an application; right?  The app is what your user interacts with and sees.
      So we're going to go back to that idea soon.
      So let's define some things.  First of all, when I say state, I mean data, so that's JSON, it's everything your app knows.  Views is your markup and your display logic, so that's all of your React, your JSX or whatever you choose for your views.
      There's a thing called actions, so this actions -- by now, let's just say they do network calls and change the state.  So it's where you do work, basically.
      Reducers tell your app how to respond to those actions and update the state.  And we're also going to talk about middleware later and all you need to know at this point is that they extend the functionality of your app.
      Before we move on, I would like to talk about pure functions.  Who here knows about pure functions?  Who here had their life changed by pure functions when they learned about them?
      Cool.  Me too.
      So pure functions have a definition.  Their output is determined only by their input values, and they have no observable side effects.  We're going to see some samples in a second.  But, basically, it means that it's a function that all it needs to be it takes in as arguments, and then its output is predictable and repeatable, and it will always give you the same output.
      So here's an example of an impure function.  I have a greet function, it takes in my name JC, and it results in good morning, JC.  But in this example, I'm calling it a 11:59 a.m.  But if I call it at 12:00 p.m., it says good afternoon, JC.  So it has a different output.
      So there's something happening there that's causing a different output and, obviously, this is a really silly example.  But in other applications, this means that you don't exactly know what your function is going to output at any particular time.
      So an example of the same function written in a pure manner is this where you pass in the time.  So that now the function has everything it needs to know to give you your output from the parameters, and so you are actually the person who's controlling the time, in this case.
      And this is a lot easier, like, for example, for testing; right?  How do you test the other one?  Like, your tests are going to fail, depending on whether you run in the morning or at night.  But in this case, you can control exactly what to test.
      Also, you can control things, like, what if the time mechanism fails and gives you back an empty string or a null?  You can check that test really easily.
      Okay.  So the testable, they're predictable, they give you the same results every time, and they're clean, so they don't have any side effects or dependencies.  So that means if you're working on this function here, and you change it, it's, you know -- sorry.  If you're working on another thing over here in your app, it's not going to break your function that's over here because it doesn't depend on other things.
      So impure functions.  So side effects are part of life.  They're not necessarily bad; right?  They're things, like, API calls, random numbers, checking time, user input, and every program contains both pure and impure things.  So it's not like it's bad, but you do kind of want to know where your impure functions are so that you know what part of your app will give you surprises.  And, you know, bugs are surprises.  Crashes are surprises.  So it's good to know to have, like, oh, it might be this part where everything's impure.
      Cool okay.  Now we know all that we need to know to talk about Redux.
      So Redux has three principles.  One has a single source of truth.  And, again, this is Strange Loop, so we're going to be, like, super, like, you know, purists about this.  So this in this case means there's only one place in your app with data; right?  You're not keeping multiple things, your components aren't keeping data, so that's what we're going to talk about today.
      State is read only.  Nothing can change your state, so your components can't change your state.  Only Redux can.  And, in fact, it doesn't change your state, it creates a new state and then replaces the state.
      Lastly, changes are made with pure functions.  We're going to talk about this later, but we know what pure functions are, so this is the third principle.
      Okay.  Now we got to one of my favorite slides, which is the Redux cycle slide.  So you start with state, and state is, again, data.  And what you want to do with state is show it to your user; right?  So your views take the state, and you have the app, and you show it to the user.  So at this point, you have an app that the user can see and interact with.  Just with these two things.  But it will be a boring website because you can't do anything yet until you have actions.
      So if the user interacts with the site or there's a browser event, it sends actions.  And actions talk to the Internet, actions do things, the work is done there.
      And then the results come back and the reducers take the action results and the state, and it's going to update the state for you.  And this is a cycle.  So now with a new state, it go down to your views and the views get updated and everyone's happy.
      So let's talk about state first.  So, again, here's our recommendation page, and this is a really cool exercise to do if you haven't done Redux yet is take a look at your pages and try to see what your state will look like; right?  So in this case, we have a title, a watch it, where to stream information, if it's liked.  And the state is, you know, a combination of these things because we not only have information for a reducer, we have information about our user or app or many things.
      So another thing you can define, which I think is pretty neat in Redux is your initial state.  So, for example, here's our actual initial state for recommendations.  We can see an empty recommendation object, the GWI info, I meant to change that is streaming information.  You can see if there was a fetch error, and you can see if it's saved or not.  And actually, like, right now, you have a pretty good idea of what this page looks like.  Let's look at a better example.  Because this is more, like, typed out.  So this is for a list page.  We have an ID, a title, by line, save recs by slugs, you can take this and think you can take a page, and it needs to have a title, it needs to have a by line.  The design is mirrored in this initial state, which I think is pretty neat.
      Okay.  So you have your state.  Now you need to show it to your user.
      So your views, again, markup and display logic React and JSX.  So Redux state is passed in this, so this is a practical when you're programming, this is not the same as this.state in React.  In fact, I'm going to say that if you're doing Redux all the way, do not use this dot state to update your state.  Everything has to go through Redux.  I see some nodding.  Cool.
      Also, views, again, fire actions through user -- the user interactions or browser events.  And so now we're ready to come back to this function; right?  Your application is a, you know, is when you give state to your UI.  So the app is, like, the output of that function.
      So here is our recommendation page, and it actually -- this is the empty state and the user's never going to see this because we do server site rendering, and it's just the shell of the page; right?  And, by the way, you can do nice things.  You can, like, tell the user, oh, we haven't fetched your data yet, we haven't done that.
      On the other side, we have your data; right?  So the way I think about this is I don't know if you've ever -- I mean, hopefully, someone here has used a sponge; right?  A dry sponge when you put it in water, it just soaks it all up and comes alive.  That's how I think about this.  When you combine these two things, you get, besides a nice animation, a full website, and it's, like, it's beautiful.  I love it.
      This also what's in this function too is the inherit separation of your views and your state; right?  Because your UI is there to just grab a state and display something.  It's not necessarily there to, like, do data stuff and calculations, it's just there to, like, take in your state.
      That's the way I think about it, by the way.
      Cool.  So the next step is actually doing something.  And, again, Strange Loop, I can quote the Haskell docs, it's great.  I can't do that anywhere else.  But actions examine and modify the current state of the world.  Okay?  They're invoked as a result of events in views, like, mounting user interactions, and they can happen asynchronously, so if you're making a network call, you have to wait to get the data, blah, blah, blah.  And they can also happen synchronously, like, opening a pop-up.  I mean, you may check with your server whether you open up a pop-up or not, but usually, you want to tell your app, hey, open this one.  No waiting.
      So some definitions.  There's this thing called actions and as the Redux docs define it, it's a payload of information.  It tells your app, like, what happened and any data associated with it.  There's a thing called action creators, which is a function that returns actions.  And there's this thing called dispatch, which is a Redux function that you give it an ack, and it takes it through that cycle that we talked about.
      I call us like to call action, action results because it communicates better than a JSON object, and it's, like, you're going off doing something, and that's not exactly what the naming convention is.
      So here's an example.  This function show watch list popover is an action creator, and it returns an action, in this case, a simple one that just has a type; right?
      So when my reducer sees that, it will see this type, and it will know to, like, do something.  Oh, the user presses this button, we should show this popover.
      That's it for actions.
      Reducers.  They tell your app how to change the state.  They're pure, so they're predictable and, again, you don't want any surprises, that's how bugs happen.  That's why the third, you know, tenant of Redux is there.
      So it computes a new state based on the results of an action, so that payload and your current state.  So that's, again, a little mathematical way to put it, it's a function that takes in your current state and an action, and it gives you back a new state.
      And let's look at an example.
      So, again, current state.action results equals new state.  So if -- here's my current state, as you can see -- oh, wait, there's my action results.  So my current state says I'm not logged in.  But the action result says.  Okay.  You logged in.  Like, this is the thing that happened.  So a reducer has to get back the same state, only with the differences based on that action.  In this case, I am logged in now.
      Here's more examples.  So -- I mean, this is the way you would actually type it out, I guess.  You have your old state and your action; right?  And you're updating the old state with the result of the acks.  In this case, am I logged in or not?  And then your view can grab that state and do whatever it wants.
      You have to return new objects.  You can't just change an object and property and return it, it has to be a completely new object.  That's one of the rules.
      Cool.  So I promised you real life examples.  So here we go.  Just as a reminder, here's our recommendation page, Broad City, great show.  And secondary reminder, we can tell people where to watch Broad City; right?  But this data is coming from a third party provider, so we can't server side load it or anything, so we have to make another call for that data.  So we have to go through how to make that call and update UI.
      Cool fetching streaming info.  So there's a couple things we need here.  First, an app that we're loading new information so that the UI can then show a spinner or something.
      The second action is to tell the app, hey, we got the data.  This is great.  Show the data.  The third action is, hey, there was an error fetching the data.  Maybe.  You the to show, like, an error message or something; right?
      So here are the different action creators that we need.  We need an action creator that tells the app we're fetching something.  So in this case, rec info fetch started is the type, and we can send the ID we want or whatever.
      And then in the reducer; right?  We look out for that type, update the state, and tell the app that we are fetching, and then the view can just grab the thing and say are we fetching?  Show a spinner.  If we're not, like, do something else.
      Okay.  We fetch the info, we have it, and as you can see up there, it takes two things, a rec ID and info.  Actually, I'm not sending the rec ID and action.  So this is good to see how you can ignore arguments.
      So we tell tell the app, hey, we fetch info and here it is in the results.  Here's what the reducer looks like.
      So it takes in, again, the old state and the action, and it gives us back a new state and differences in this case telling the app, hey, we're not fetching, so stop whatever spinners you're spinning and also, here's the streaming info.  No error.  We're good.
      Third type is the third thing we need is there was an error, so we can say, like, hey, there was an error, here's the error message, and it takes in an error for the arguments.
      And then the reducers, again, we saw this before, old state action, new state with the differences.  Hey, we're no longer loading, but there was an error; right?
      So right now, we just made the action creators.  We haven't actually fetched anything yet.  We just prepared and laid out the ground work to do the actual fetching.  So here's an example of an asynchronous action creator.  Sorry for the text.  A lot of code.  But, basically, we can highlight it.  So here's the first action creator that we made.  We're fetching the info.  Here's the second one -- oh, no.  Here's the API call; right?  So we're going to our API to get the info.
      If it's successful, and we have the info, we tell the app, hey, we succeeded, here's the info.  And if there's an error, we send -- oh.  I should have sent the error in there.
      But, basically, you can send the error in there to update the state.  And then the other thing to notice here is that we're using dispatch to grab these actions that are returned by the action creators and take them through the cycle.
      And that's it.  That's all you need to know to make an app with Redux.  And, actually, this is all I knew when I shipped Watching for the first time.  So yay.  Cool.  But the talk isn't over yet.  There's more parts.
      Okay.  Reminder before we start part two talking about containers, we have cards, they're everywhere and carousels.  Carousels are when cards are in multiple place, and you can swipe through or whatever.
      So let's talk about containers because these are the things that I started learning about after I shipped an app and had time to actually learn about Redux.
      So they bridge Redux to your React views.  And a bridge links two things together but you know the two things are separate, which I think is an app metaphor.  So, no, Redux in your React and so what you should be doing in your views and your React is only focus on turning data into views and some call backs.  That's all you should be thinking about.  So containers help you separate those two concerns.
      So you can also define and filter what data each components receive.  If I'm working on my streaming info thing, it shouldn't be getting information about whether something is saved or not.  You can control that.
      And also, it allows you to, like, handle things you don't necessarily want in your views like analytics.  Biel get to that later in another idea.  But, basically, you can start taking things away from your views so that all you're doing is React in your views and then having those containers, like, link everything together.
      So here is a rough sketch of our app.  After we launched.  And, again, cards you can save and stuff; right?  So we had a feature request where we had to implement liking for cards; right?  So if you like a thing, like Broad City, you can click the like on the card, and it will like it.  And, basically, we had an issue because cards are everywhere, and they're the least -- the tree of this application.  So if we wanted to implement like and cards, if you see the little stars, that means that we changed the thing.
      So we had to change all the cards; right?  And then if you look at the very top, that app has a thick border, that means it has access to the data, via a container.  Okay?  So containers give you access to the data.
      So everything else was just getting data that you props.  So we change the cards, and we changed app so that we got the new like data; right?  But the problem is we have to connect those dots.  So in order to implement something in cards, which are everywhere, we had to change our feed, the posts, the carousels, the rec pages, the watch lists, the search, and right now there's a problem; right?  How come adding one feature in this card thing means that we need to touch our whole app?  It takes time, it's, you know, you're changing more files, so there's more entropy and possibility for bugs, so that's no bueno.
      Cool.  So you can use multiple containers, and that means you can give parts of your components access to data more easily.  And you should definitely consider it when adding data involves this many files, and you should use it for codes that are super essential.  So, like, our cards are everywhere, they're super essential.  Or also for code that's quote nonprimary to the app like ads; right?  So sometimes ads have requirements, like, hey, you need to change that thing, and we only want to make that change in one place because if -- otherwise, we have to change, like, our whole app for this requirement.  Not very good.
      And so there is a tradeoff; right?  Like, why wouldn't you use multiple containers everywhere?  There's a tradeoff between access to state versus pure components because now, for example, if we share our feed, it's not going to be shareable to another team, unless they're also using Redux; right?  Because they need the idea of containers.
      So now we can share this, like, card component but not the card container, and definitely not the feed container that includes, you know -- sorry the feed component that includes containers in it.  So there's tradeoffs.
      Cool.  So how does that same problem apply now that we're using multiple containers?  As you can see in the bottom, the cards now have thick borders.  That means that their components are wrapped by containers, and they have access to the data directly.  To the store.
      So, basically, we just change the cards component, and that's it.  And it's a lot better.  Your diffs are a lot smaller but, again, there's tradeoffs, so I would definitely recommend a case like this where you have one import component across your whole app.
      Okay.  We've gotten to part three.  Simplifying data relationships with selectors.  And before we talk about selectors, we need to talk about derived data.  Who here knows about derived data?  Kind of?
      Cool so derived data is data that you can calculate from your states.  The goals of this is to store the least amount of possible states.  Okay?  So, for example, if you're working on a database; right?  And you have a user, the user has a first name or the user has a last name, and you want to display, like, full name.  Are you also going to store the full name when you can just compute it by adding the first name and the last name?
      So in this case, the full name is the derived data.
      You can also derive data, like, combine from multiple sources.  So if we have a recommendation from The New York Times and screaming information from a third party, we can make this object that has data from multiple sources.
      So merging data.  Here's an example.  We have our post, we have our saved state.  So it tells us whether an ID is either saved or not in this user -- the user's save thing.  And we can derive a single object that merges the post.  And if you can see down there, it has an if saved equals true.
      So we have this object that comes from two sources, which is really handy.
      Cool.  So selectors are the things that you use to compute derived data.  There's a library for this.  They're composable, so you can use selectors and other selectors.  And the cool thing is they're also memoized, so you can, like -- they're not recomputed unless things changed.  They're, like, cached, so you get some performance benefits, especially when you're doing really, like, a lot of data, and you're combining them, it won't recombine them.  It will remember them and won't recombine them unless something changed.
      So here's some examples.  This is the simplest kind of selector.  So, basically, the selector's called get posts.  You give it a state, and it knows where in your state to get the post; right?
      Same here.  Save statuses by ID.  Where is this in my list?  It's in the watch list part.  Cool.
      So here's an actual selector.  So we're creating a selector, and the way the syntax works is you give it an array of selectors.  And a function where the arguments of the function mirror -- it's, like, the result of the array that you sent in.  So we're sending in get post, the selector that we just made in the previous slide, and we're getting post here.  So it got the post; right?
      Same thing, get save statuses, it got the save statuses.
      And what we're doing here is, again, we're expanding the post, each post to inject the saved data to it.  So that each post now has, hey, this thing is saved.
      Here's another example.  So this is the one we made in the previous slide, so we're chaining selectors now.  Here's the post with the save statuses.  Here's the streaming info ID so, like, where to watch something.  And, again, we're injecting the information of where to watch something into this object, this post object.
      So at the end of this chain, our watching post from The New York Times has information from our, like, save servers.  And also information from a third party; right?
      Oh, yes, the other thing is I found -- so, basically, if a user saved something, that selector is going to become invalid and recomputes; right?  If the streaming service changes, this selector on the slide is going to be needed to recompute.  But the problem is that the user's going to save something more often than the streaming service change.  So actually, while making these slides, I found a performance opportunity -- improvement opportunity in our code, which is pretty cool.  So we should flip; right?  We should change -- we should start the selectors with things that don't change often and end with the things that change more often.
      Cool.  Okay.  Business logic.
      So I have my own definition for business logic, and it's the things that people tell you to add to your app.
      [Laughter]
      It's stuff that's nonessential to the user for an optimal experience of the product.  I hope that isn't too forced.  But, yeah.  So, basically, I mean, working at a company, you get a lot of requirements from a lot of different teams, and they all expect it to happen quickly.  And you as a developer don't want that rush or expectation to, like, mess things up organizationally or for bugs or whatever.
      So here, I'm talking specifically in my experience about analytics, on boarding, and ads; right?  So we're going to talk about some best practice to implement this using pure components and having Redux help us along.
      So the first thing is app on clients?  We need to differentiate between server side renderers and client side.  Because we have front-end libraries that if we render on the server side, it breaks things; right?  So we need to be able to say, hey, if you're in the server, do not render this also, those renders have to be the same as in the clients.  So the clients also has to do a server side render before it mounts on the clients; right?  Because otherwise, the two diffs are going to be invalid and then, you know, I guess out of the scope of this talk.
      So we also want to avoid using internal state.  Like, we could do this by saying this.state.update, you're not in the client.  When you mount, you say okay.  Now you're on the client and have your component redo that thing.
      But that makes the component pure, and it will behave differently, depending on the circumstances where it is.
      And we do this by adding something to our state that we just call is app on client.  So we can do this through Redux, and I'll show you how in a second.  But, basically, all we have to do now is if you're in the client, do this, if you're not, do this, and we do it all through our Redux state, and we avoid kind of setting local state.
      The other thing we do is, like, window size, so, like, advertising is a real requirement.  They need a different URL call, based on whether the user is on a mobile device or a desktop device.  Now, this is hard for me because, for me, there's no such thing as mobile or desktop.  It's all just one Web page, and there's no difference; right?  And you can't do it with responsive techniques because in this case, advertising was using it to, like, analytics; right?  So, like, doing it responsively as you put both in the HTML, and you hide one depending on your screen syce; right?  Using CSS, in this case, it would load both images, so it would double count analytics, and that's not good.
      So the solution is to only render this ad when we knew the window size, and we had the same technique where we -- where the app mounts, we update our Redux state with the window size whether it's mobile or desktop and we know that not before we render this app.
      And that leads me to something I'm calling an impure top component.  By the way, this was an epiphany that I had yesterday.  So, basically, what we do, what I try to do in my application is get rid of all of the impure functions and take them all the way up to the top-most component.  Because at least I know if something weird's happening, that's where all of my impure stuff is and everything else is going to be well behaved.
      So there's our initial state for our app.  We have our window size on mounts and our is app on clients with their initial values.  And then when the app component mounts, we can update those things; right?  So this bottom function only runs when we're in the browser.  And so we update the window size, and we update if you're on the client or not.
      So middleware, we had this issue where we had to update the URL based on a search tag; right?  So if you click on reality, we want the URL to say you're looking for binge-worthy reality shows.
      So middlewares exist between the action and the reducer; right?  And they respond to actions before or after a state is updated.  They're composable, so you can have a chain of them, and they're very useful for implementing side effects.
      So back to this issue, the way that we did it was when you click a tag, we just take it through Redux, it updates the store, and we use the middleware to say.  Okay.  What's the new states?  And based on that, we just have a function that maps the new state to the URL, and we update the URL.  Because otherwise, you know, you can't do this in the reducer because having a side effect, you're changing the URL.  You can do this in an action, but it's weird to be, like, okay.  Update tags and URL, like, they seem two different things.  And you can chain them but, again, you can make them asynchronous.  It's kind of weird.  And you shouldn't do in your views; right?  Because then you would have to change until your component gets new props and then check the new state and the old state and then also your logic will be in two different places, so it's complicated.  It's a lot easier with middleware.
      And the take away with middleware is you can now describe things, side effects in a functional manner instead of just chaining them.
      So this is a skeleton, this is how middlewares work.  You can first check if you're interested in the action that's not being run.  You can get the state before you run the action through the reducer.  Then you have to run the action through the reducer, and then you get the state after it.
      So what we do here is we update the state, we grab the state, and then get the selected tags and then just have this function that maps this new state to this new URL, so it's very nice.
      And then quickly, so for on boarding, being also do this, you can describe on boarding events.  So if the user clicks on a thing; right?  You can use middleware to say, like, okay.  They click save.  Is this their first time in the app?  Because you have that in Redux.  And then based on that, you can show this on boarding thing; right?  Instead of describing this logic in your views, you have this in another place for middleware.
      And then, yeah, tightly coupled.  Same thing for analytics.  You can have this middleware that grabs your analytics and just sends stuff like crazy.  Or you can filter and select which events you're -- you want to send to analytics.
      The other thing is you'll have a nice mapping between your Redux actions and your analytics.  So if your analytics' person's, like, hey, what do we do with analytics?  You can just send them all of your Redux actions and have them deal with it.
      So now we're almost done.  This is the last slide.  We saw how views take in state to display an app.  We saw how views can dispatch actions to, like, do stuff in the world and create a result.  That result is then passed on to the reducer, and the reducer knows how to update your state based on what happened.  And then the state goes through the views, and everything happens over again.
      The new things that hopefully we learned today is we have containers and selectors that help you deal with data, combine them and memoize them and all of that fun stuff and separate your Redux from just focusing on pure React views.
      We have middleware that can do stuff before and after reducers and middleware is a great place where you can describe side effects instead of having to do it imperatively somewhere else.
      And then the last thing that I hope you take away is always compartmentalize your impure stuff.
      So what I like to do is send it to the top component or actions so that everywhere else in the app everything is well behaved.  And this separation concerns with Redux and pure and impure is something that allowed us in the Watching team to just build a website, you know, less than a year, like, we had to change our whole UI, and it was really easy because we just changed the views part.  Nothing else changed.  We also changed the factor and in that case, we just changed the views part.
      So if you're looking to move quickly with less mistakes, this is something that you should do.
      Thank you.
      [Applause]
      Captions provided by @chaselfrazier and.
      @whitecoatcapxg.
