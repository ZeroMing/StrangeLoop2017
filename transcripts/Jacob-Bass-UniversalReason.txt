      "Universal Reason."
      By: Jacob Bass.
      >> Good to go?  Everyone can hear me okay?  Cool.  I think we're good to go.  Hi, I'm Jacob.  Thank you very much for coming.  Today, I'm going to be speaking about ReasonML.  I'm really excited to talk about this.  I've got a lot of good content.  I hope everyone gets some really good stuff out of it.
      I go home at the end of the day looking like this a lot.  And the reason that I look like this is that writing correct software is really hard.  But it's really hard doing it in a language that has no real formal semantic understanding of what correct software actually means.  So I spend a lot of time writing JavaScript, a lot of time writing Ruby, a lot of time writing dynamic programming languages.  And in languages that don't have a strong type system, it's very difficult to express whether or not something is correct.  So what we're going to cover today is how using a language like reason can actually improve your developer experience, improve your day to day experience, improve the quality of the software you ship, and improve your confidence in the product you're actually delivering.
      So how many different implementations do you think you could write for the function that's on the screen?  So the function should read as an as yet unnamed function of any possible type A that returns any possible type A.
      With such a breath of apoliticability, there are no restrictions on the input time type.  On the only restriction on the output type is it's the same type.  How many functions do you think you could write?
      Well, if we constrict the solution space, definitely respond, don't look forever.  Don't throw exceptions, and we agree that we're going to be pure and have no side effects, there's only one implementation, there's only one thing you can do.  And the only thing you can do is return the exact same type that you were given at the beginning.  The exact same value that you were given at the beginning.  And the reason of that is because you know nothing about the type that is being passed into the function.  Which means you can't assert any kind of behavior that is legal to perform on that type.  From a correctness perspective, your hands are tied behind your back.  This was a very, very confronting me for me the first time I came across it that having restrictions on the input types for a program could actually grant you more freedom and having absolute freedom on the input types of a program was very constricting.
      But what I think, basically, made me realize that, made me kind of understand that was looking at the kind of code that exists in a lot of the dynamic systems that I work with.
      So a lot of the code looks like this:  We have a lot of very, very well named variables.  We have a lot of checks for the types of values of the things we're dealing with be and we have to rely on things like commenting or documentation to explain to us why the function is doing the thing that it's doing.  We don't have static analysis, we don't have compiler safety we begin to rely on run time exceptions for control flow to help us kind of differentiate between the ways that we are programming.
      And I think the reason do that is that a lot of the time, languages that give us static analysis are painful to use.  They require us to write annotations in every variable that we find or they're not safe themselves, and it becomes a pain, and we don't get any tradeoff or value for that.
      But what if there was a way to get a strong compile time static analysis safety in your program?  Without giving off the things about making programming in a dynamic language fun?  Where you don't have to write and type annotation on every single variable on your program, where you don't have to deal with the difficulty of null checks at every possible function open.  What if this language was available to you now to use?
      So the language that I'm going to introduce is called reason.  ReasonML.  And reason is a language, a syntax and a tool chain, effectively to define over the Ocaml language.  It's a functional programming language.  Probably about 20 something years old.  Long history in academia and in industry.  And the reason it's being developed by Facebook as kind of an introductory functional programming language for people who wouldn't have come across these concepts otherwise.  Born of recognizing that the barrier to entry with OCAML was higher than most people were willing to climb over to get to the benefits.
      So the other really interesting thing about reason and what positions for me today is it actually compiles really, really well to JavaScript.
      So that makes it very, very compelling for general purpose programming.  As someone who works on the Web if I can't compile to JavaScript, I can't actually do anything in a browser.  I'm stuck with static HTML being sent back from a controller.  Difficult to work with.  Very difficult to explain to a product manager why you might want to downgrade your experience because the correctness of your back-end system is important.  By having something that can compile to JavaScript, we get the best of both worlds.  We get all in the front-end and also complete power time safety at compile time effectively.  A lot of the things I'm going to discuss today will be very, very general functional programming benefits.  There are a couple of things that are specific to reason and to the script compilers, which is the compiler we use to go to JavaScript.  But the vast majority is just functional programming techniques or typed programming techniques.
      So we'll start by discussing the ways in which a back-end system might be maybe not as safe as you like it to be.  And this is a really important topic for me because from my perspective, the back-end is the really, really important bit of a Web system.  It's the bit that's connected to your source of truth.  Presumably it's connected to your database.  And in the end, what that means if that isn't correct, if that isn't reliable, then you really have no way to be comfortable that your system is performing what you would like it to.
      And it's very important to me that a back-end system be correct.  But they are so seldomly so.  So back on the JavaScript theme, this is a controller from the express JS HTTP framework.  And this is a pretty common piece of code that I see in a lot of different applications that I've worked on.  We have a controller that takes a request open, a response object, and and a next object, and it checks to see if the body contains a variable.  And if it does, it responds.  But there's an error here.  There's a really, really big bug here.
      Can everyone see the bug?
      The bug is that if the body is null, we throw an error and don't respond.  Or if it doesn't contain any of the variables, we don't respond.  Which means there are a number of code paths from JavaScript's perspective that might occur in our system that we don't protect against and nothing is helping us be aware that we don't protect against.  We have no tooling or information that helps us know, hey, you probably want to cover these other cases.  You haven't, and that might lead to incorrect software.
      Where the house built on foundations of straw, rather than stone.
      So what can we do to improve this?  Well, the first glaring issue is that JavaScript's return types don't actually exist.  There's no such thing as a return type for JavaScript because there's no type system.  Which means asserting behavior from a static analysis perspective is very difficult.  It's very difficult to know looking at a piece of JavaScript code what is the actual return type?  What is the actual input type for this?
      So let's look at what we might do to improve that situation.  And we're going to set a very, very strong kind of contradiction ourselves.  Every function we deal with should take arguments.  And at the very least, it must return a meaningful result so that we know the type of response of a function so that we can assert the behavior of the function so that we know more about them.
      So we're going to look at what it means to use the express back-end from inside reason.  So we're going to define some of the foreign function interface bindings using the script compiler, and we're going to call the JavaScript express exposes from inside reason but do it in a type safe manner.  So initially what we do is we describe a abstract type DOM.  It's a type that doesn't have a constructer, which means it can be returned from something but not created from itself.
      We'll go into the definitions of those models, we define request, response, next, and middleware.  The types that we saw before, the next types.  Middleware is the definition of what a controller of what a middleware in our system is going to look like.
      So in this case, we see what the initial definition of what a model looks like as far as reason is concerned.  A module in reason will get into much more detail later.  But for the moment, you can think of a module as a name space in which types and values exist and will not clash with types and values in other name spaces.  The process for allowing us to encapsulate behavior without clashing on different named functions.
      So we define the three modules request, response, and next here.  We give them each in a type T.  You'll see that they have type T in a lot of modules in reason.  It's convention for what the name type of the function is, but it doesn't actually mean anything special.  It's just that there is a type T available.  The request is very -- the response has our first example of a script.  And what that is the call to send HTML.  And what we do with send HTML is we actually compile that down to a JavaScript statement that says the first argument you give this function is going to be the thing that we call send on.  The second argument you give this function is what we're going to call send with.
      And we're going to return from that done.  So this is the first function we can see in our system that can actually produce a type of done for this.  We say when send HTML is finished being applied, we're done in the controller.
      We also define our next module.  So our next module also has a type T.  This time next type is not abstract.  It actually has a constructer.  And we see that next is a function.  It's a function that takes something that might be nullable and returns a done.  So we now have two ways in our system to return done.  We can either say something went wrong, and we call them next with a potential error and let that flow take place.  Or we say everything worked as we expected to, and we're going to send HTML back to the client.
      So we're now ready to define a middleware in this system.  And we saw that a middleware has a type T, a request.T, response.T, and next.T and return done.  So this is the very, very important bit of the system.  This is the bit that I like.  We guarantee at compile time with no exceptions that our middleware function absolutely responds to the client.  And the way that we know that is that the only functions in the entire code base that can produce done are send HTML and next.t.  Nothing else can do that.  Because of that, we have compile time safety, compile time assurance that we absolutely -- no matter what else we do inside the controller respond to the client.
      So this is what it would look like then to construct a middleware of that time.  We define a function F and F we see takes three parameters.  Ref, res, and next.  And we have a switch statement.  So this is a really cool concept called patent matching.  It can be thought of similar to an if statement but where an if statement operates on values, it operates on types.  So an if statement can check what the valuable of a variable is and perform this code branch if it's one or two, a patent match looks at the types.  In this case, it looks at the algebraic data type of the optional type, and we're basically saying if we have some computation that returns none, consider that an error and respond to the client that something has gone wrong.
      And if we have a response from our function that is some, if somethings gone right, take the inside of that and respond to the client in the appropriate way.  So we match on the actual construction of the value, rather than on the value itself.
      And what we can see here with the really interesting thing looking at this is there are no type annotations; right?  There's no boilerplate, nothing that gets in the way of defining our functionality.  So we don't have to actually write type annotations.  The compiler can infer them from how these functions are used.  In this case by passing it into the app.get function, the compiler goes cool.  Middleware.t, that means res is a response.t and so on.
      The responsibility for actually determining what is going on belongs to the compiler, not to me because I'm nowhere near as smart as a compiler.  The responsibility for helping the compiler when it gets confused now is only ours.
      But that lifts a whole bunch of responsibility off our plate.  And it helps us hugely identify that the only paths that we now need to write tests for are the insides of controllers to make sure that our business logic is correct.  That they respond with the correct data.
      We don't actually ever need to care again do all of our controllers respond.  Do they catch errors?  Do they handle problems?  Do they do any of the things?  They definitely do.  The compiler.
      The compiler not only assures us of it in the happy path but also when things go wrong.  So in this case, we're patent matching and saying for every song that occurs, respond.  But we're new to the code base and haven't yet learned what the business rules are, and we don't know why something might not be returned wrong.  And I would like to check it out later.  But logging is not the same as responding to the client and the compiler will not let that happen.  It absolutely will not.  Which protects us from doing things that we maybe don't know whether or not to do.  We don't have to have 100% knowledge of the code base.  We can push in the type system the rules around the code base is structured as it is and rely on the compiler to protect not only us but people who are new to our project to help them write correct code.
      So we've seen a way to improve our back-end system by using the type system to help us write correct code.  Let's take a look at the front-end.
      I have somewhat of a love hate relationship with front-end programming.  I think I've probably only started to enjoy it when React was released.  And a big reason for that was front-end programming for the longest time has been slung with very much abandonment.  It does not have a concept of correctness and a big reason for that is the JavaScript, the language of the front-end is not correct.  Fundamentally, it is a very difficult language to write correct code for.  And you can see this in a lot of the efforts that have been created, and they are admirable efforts to provide static analysis for JavaScript.  The flow, TypeScript, Clojure compiler, these are all very powerful tools and a lot of effort has gone into helping us write safer JavaScript.  But they each have to make tradeoffs to allow code to run that is valid JavaScript code.  But that is not valid correct code.
      So you'll see, for instance, unify types that are unwrapped, so you can have a value that is both a string or a null and the compiler doesn't care.  Flow doesn't care.  That's a totally valid state to be in.  From a correctness perspective, that is very difficult to deal with.
      So what we're going to look at now is instead of trying to write JavaScript correctly, let's rather focus on I wanted to say that this particular part of my program should be correct, and I'll deal with the fact that I write JavaScript in other parts and let that be as correct or incorrect as I can get it.  But I'm going to compile two JavaScript in this other bit.
      So the framework that I'm going to describe this in React.  Are there any people who use React in the audience?  A sea of hands.  Not super surprising these days.  So React, as I mentioned before, Reacting is developed by Facebook, obviously.  Reason also developed by Facebook and interestingly, Reason was created by the same person who created React.  So Jordan was the person who came up with Reacting and Reason was also created by Jordan.  And React was in standard HTML.  Which means bringing it back into Reason, we come full circle.  So we're going to go through a little bit about how we can structure a React code base in reason and what the benefits of that might be.
      So initially to start with, we're going to deal with just the hello, world example.  We have a greeting component.  For anyone who's not familiar with React, this is a function effectively that will take some data and respond with some HTML.  That's effectively the computation that we're performing.  And we see here we have a random method that just takes the prop that we passed and returns it.  The other thing we can see is that we have this static member prop types.  Prop types is a dynamic run time evaluation of the types that are passed as arguments to a React component.
      It's the way that in vanilla JavaScript, we assert whether or not the values that we're passing obey the contract that we have written to make this hierarchy work.  And this is the method that we rely on when we don't have flow or static analysis or the language with these semantics built in.
      But as with all dynamic run time evaluation techniques, we have to trace every single pathway of our program in order to know whether or not we've actually hit all of the bits that we care about.  These things run at run time, so we don't have any real easy way to tell does this actually -- is this actually safe everywhere?  Does this obey the contract that I want it to everywhere?  Unless we trace each of those paths dynamically.  So this is one of the drawbacks of using pure prop types and one of the drawbacks of using just JavaScript.  It's more or less manageable when you have a very small project.  More or less manageable when you can keep the state of your entire application in your head.  As soon as you have anything larger than that, it's very, very difficult.  We find ourselves at the mercy of our time or our tooling, and in a refactor or in a crunch, these are the kinds of things that tend to fall by the wayside.  We're okay with that error.  We're okay with that prop type error.  We don't really mind.  We'll come back to it later, and we never come back to it later.
      So what can we do?  Well, looking at how reason treats React, reason up to what we've seen from now is a programming language and reason React components are strongly-typed functions.  So in this case, a reason React component is just a module, like I said before, a name space that has two members.  A component and a make function.  And the make function is the thing that is analogous to the state component.  It's a function of some props that returns something that produces HTML.
      And what we have here is we see our greeting component from before.  We define it as taking a message property and a children property that we're ignoring, as far as the body is concerned because we don't use it.  And we take the component that we've defined by calling reason React stateless component, and we spread it apart.  And we override any of the defaults that we wanted to override to change the behavior.
      So now we have a fully functional React component.  So this is the record syntax from React.  Anything in curly braces by itself is a record.  A record is something that has very particular properties.  It's effectively an object with predefined properties and values.  And what we're doing here is we're saying component comes back with a number of these properties, but we want to overwrite the render property, and that's what we're going to use to rerender HTML.
      So here we have a way to do something a little bit more interesting.  We now want to say that we want some kind of dinoism in our system, we want to have some state, some interaction.  And the reason React is fairly unique in that it doesn't -- it allows you to compartmentalize that state at any point in your hierarchy, at any point in your tree.  The way it does that is by a concept called reducer component.  And that's the function that we actually use to create the component variable this time.
      So a reducer component is an ordinary React component that has a state and allows you to update that state from anywhere in your tree.
      For anywhere in your subtree, rather.  And so on rendering this component, we can generate a number of call backs and call those to actions that might take place.  And then when those actions take place, we call those call backs and have the effect of that be that the state updates, causing a rerender again, and we update the subtree.
      So the way that we do that is we first define a type for action and a type for state.  The action is the actions that we want our reducer to be able to operate on.  So we say that we're going to listen for clicks, and we're going to listen for restarts.  These aren't magic terms.  These are completely arbitrary.  What I'm going to do later is attach those to a click event.  We also have some type of state, which, again, is a record.  And in this case, we say that state is a clicks counter, which is an integer.  We define our reducer component, which is the React reducer component function, which we override some default properties on that.  We override the reducer function and the render function.
      So we override the initial state function to say initially, give me back a record where clicks are set to zero and restarters set to zero.  This now gives us the time to override those and gives us the position to override those.  We then define our reducer function as something that returns an update to that record.  And you'll see that the shape that it returns is exactly the same as the initial state shape.  Exactly the same as the state shape.  We have an action that we take in, and we have the current state of the application at the time the reducer's called.
      We then switch, we patent on the action that's occurred.  When we've hit a click, we want to update the click counter, we want to leave the restarts counter exactly as it is.  When we hit a restart, we want to set the click counter back to zero, and we want to increment the counter.
      So this is the way in which you handle datasets effectively.  The way that you handle data propagating through your system.  Either way, we put this in HTML, attach the functions that are available to us through the HTML nodes to handle the events, and we interpolate the state into a string.
      For anyone who works with Elm or Redux, this should look very familiar.  The interesting thing is that as for the reason React bindingss, you don't actually need a state library.  Out of the box, it does everything that Redux does better and with compile time safety.  You actually know ahead of time I don't accidentally listen to an action that I don't know how to handle.  Everything that's in my reducer is also produced.  Everything that's in my actions is also part of my reducer.  There's no impedance mismatch.  Everything is handled for you by the compiler.
      A couple of statistics on using reason React on the front-end.  So the messenger.com website, Facebook's messenger website is at about 50% conversion for the front-end.  A complete build of the system using the compiler takes about two seconds and incremental build takes about 100 milliseconds.
      The amount of time it takes to type check every single statement inside your code base is faster than you can even say the word unit test.
      Total bugs introduced over the course of the year.  Ten.  Which is incredible.  It's great.  It's a great number.  And the idea is that by having these correct checks hit us at compile time, we never discover them at run time.  We discover them all while we're actually working on them, which means we don't worry so much about what the correctness state is in production but much safer at compile time.
      So we've shown that the reason React API protects all of the things we like about React.  It gives us all of the same dynamic features that we enjoy about writing React without any of the drawbacks of what we would consider a ecstatic analysis system would be.  Our code with compile time type checking, which is very valuable, and it also helps us share or compose or refactor these components without having to worry did we change something somewhere that we didn't track?
      So the refactoring is the bit that I really, really like about this process, about the inference.  I find that I -- like I mentioned before, I don't write very many type annotations, I'll only write them when I'm working in a library.  But in the actual implementation of the code, you just write code.  You don't write type annotations, which is really nice because you don't necessarily have to think up front completely what is the bear minimum type that I want to support here.
      But when it comes time to rechange the factor, you don't have to go, well, I changed that, now does it change and break anywhere else?  The type system keeps track of that for you.  It helps you refactor.
      So I actually have my wife to blame slash congratulate for this slide.  She told me the word verlep five years ago, and it's really fun to say.  It's a really fun word to say.  But it means, like, wilted or limp.  And that's effectively how I feel about validation being done in JavaScript on the back-end.  Validation is a very, very important, data validation is very, very important thing to perform.  When we have data coming in from an untrusted source knowing that it obeys the business rules that we have set for that data is very important.  Again, source of truth back-end.  These things are kind of vital.  But one of the things that you don't have in a dynamic language is the alternate to know that everywhere I persist data, did I first validate?
      So this is the data structure that we're going to pass around.  This is what we're going to use as a -- as an example for what it means to persist or validate data throughout our system.  We have a person and a person is defined as having a name and an age.  And we said that the name is a string, we said that the int is a -- sorry.  The age is an int, and this is the data structure that we're going to use.  If we were going to deal with this data structure from JavaScript, we would have the data structure come in from some source, we would pass it through a validate function, it would come out the other side, we would check the results.  If something went wrong, we would say cool.  Get rid of it.  Throw an error.  If something went right, we would pass it on to save.
      But like I said before, we don't have any way to know every time someone calls save, did they first call validate?  Every time someone calls process, do they first call validate?  We don't have anything to help us check for these problems.
      So the way that we tend to deal with this is we either very tightly couple these into an ORM behind the scenes.  So we have some private Boolean property is valid and the ORM will set that property before it saves, and that will then -- if we try to save something before it's valid, we will automatically call validate, we can call validate beforehand, but it very tightly couples the validation to the persistence layout.  But there are other things that we might want to validate and deal with, and we don't have a good data structure or good safety assurance that we've done this thing.
      As a side note, did you know that reason was haunted?  So I'm speaking of phantom types.  Phantom types are a type decoration where the types on the left-hand side or the variables on the left-hand side don't appear on the right-hand side.  So in this case, we have type T of A equals string.  The polymorphic A doesn't appear on the right-hand side.  What does that mean?
      Well, we have type T of A is string, and we can now define that X and Y are both strings, but we say that they're really T of int.  Which doesn't really affect how we can use X and Y.  We can still concatenate them together and when we log out the result, we still get through bar.  Nothings changed.  So this seems like a wacky esoteric technique for mocking around the type system.  But if we couple them with the opaque types, we actually get something really powerful.
      So before I show how we're going to use them to protect validation, I just want to go through what the API we would like to have is.
      So we would like to have a way of saying that a person validate a rule produce a person.  But any operations that rely on that person being validated before we -- before we do that operations, we must make sure that we go through validate first.  At compile time.  Not at run time.
      So we see here that we have an introduction to the pipe operator.  Pipe operators are just a way of taking an expression on the left-hand side and inserting it in the tail position on the right-hand side.  And we can see here when we do person validate or make name age, and we try to save it directly, we should fail at compile time we should fail.  When we have person validate, we pass it through validate, and then we use the option to say if it's nonreturn non,if it's sum, perform this operation, we should succeed at compile time.
      So what does that look like?  This is a pretty big example, I'm going to break it up into smaller pieces.  But the idea is that we can define some module interface, some type to say these are the bear minimum things you need to define to be considered a validater, and then we can define information of that and say cool this is what I validate with.  The important thing to note here is that in the validator type, the module type validator, the type of T is abstract.  In the implementation, the type of T has a constructor.  Effectively what this gives us is an opaque type.  Is gives us something from within the module itself we can reference the person constructor.  But from outside the model, we have no way to do so.
      And the powerful thing with this is that it means no one, unless they use the methods exposed by the modeling can construct a person.  Which means that the only possible way to get a person is to go through all the exposed public interface of the model.
      So let's go through what that means and how that's you'll of.
      So we have a module type person validator.  We have two opaque types valid and invalid or two abstract types.  And then we have a type T of A.  T polymorphic and A.  We then define a method make, and we say that make from the type perspective is something that takes a string and an int and returns a T invalid.  So we saw before that you can define something as coming back T polymorphic entirely, and we can see can say that because T polymorphic only on T invalid.  We then see the only function that we ever define that takes something from T invalid to something of T valid.  We say that validate is a function that takes a T invalid and returns with an option T valid.  We use option here just for the ease of the demonstration in a practical system system, I would probably use either or results to capture where something went wrong.  But if it's invalid and our validation checks fail, return none.  And if it's valid whereby within return some of the T valid.
      Finally, we see the method that we're going to use to show that the validation check will fail at compile time if we try to sidestep it.  In this case, some save method that we can call that will take a person and put them into a database.
      So let's see what that will look like.  So we take a person, hi, me, and we pass them through a validate and pass them through option F map, and we save them.  Because the person obeys all the validation rules, the construction happens correctly, we get back at T invalid.  We then have a T invalid that we pass through validate, the validation succeeds, we get through T valid, we then pass that through the save method which takes a T valid and returns a T valid.  All of this works.
      What if we have someone who's too young?  So from our validation perspective, we say that we don't want to solve people in our driver database who are under the age of 18.  We have someone very clearly under the age of 18.  So we pass them through the validate and validate fails.  From the algebraic data type, we get back the nonconstructer.  When we hit option F map, it says cool, you have none, don't worry about it.  This is all still legally, like, valid.  It's all correct.  We don't actually hit the compile system yet.  But we receive someone who's non,we don't try to call save with non.  We just let that go.
      What if we do something a little sneaky?  So what if we then take person validator or create a person and then try to save them directly?  So we can see that we get a compile time error.  So this is where the phantom types really shine is that the faq we receive a T invalid from make and the fact that we say save works on T valid means that at compile time, we are assured that we never, ever call a function with a T invalid with a T valid.  Really, really valuable.  And we can see how we get the error T invalid is not compatible for T valid.
      And then similarly if we do something really, really sneaky, and we start with not valid, and we try to cast that to a valid, taking advantage of what we think we know about the system where we know that it's a person on the other end, maybe we can just automatically cast it to a T valid, they're all the same concrete type the oner side.  But, again, the compiler says absolutely not.  Error type T valid is not compatible with type T invalid returned by make.  You cannot cast between types like that.
      So there is no way in our system, no way at all to save this object, unless it first passes through Val decade, and we are assured at compile time that there is no way that someone has done this.
      The really interesting thing about this is when we look at the implementation, there is no function that makes use of valid or invalid.  Make doesn't mention T invalid.  Validate doesn't mention T valid.  Save doesn't mention valid.  They all do stuff.  The interface will basically set that that type is T valid or T invalid.  But from the implementation's perspective, none of that exists.  And the reason why that should be interesting is that we have an understanding now that our friendly ghosts don't actually exist at run time.  There's no wrap or unwrap penalty for using this technique, which is really powerfully.  We have no run time penalty for compile time gating the behavior of our system.  We have a huge assurance that our system is operating the way we intend it to, and we know that we can do this performingly.  So this is very important.  Very useful.
      So we've seen that there are very, very strong things that we can do to push the behavior that we would like to have to our type system.  The important thing to note here is that we haven't actually asserted anything in the type system about what our validator does.  It just validates.  We don't know whether it validates correctly or incorrectly from our business rules, and we should unit test that.  But we are freed from having to assert that every validator is called before saved.  We're freed from having to trace every single controller and service path to our application to say did I in this path call save -- call validate before I called save to get into the database?  So these are the decisions that it takes away from you needing to make.
      Finally, I'll end on some of the things that I think are really fun about the language.  One of the things that I try to evaluate an language on when I first start playing with it is the ability to express abstractions.  I really like abstractions just for their own sake.  And in this case, reason isn't found lacking.  So the first one that we touch on is modules.  And we spoke about modules a couple of times.  Modules are the most widely used abstraction feature in Reason.  Kind of cheating.  And it's cheating because every file in reason is a module.  So when you create a file and write statements, the compiler wrap all the statements up, store them in a module, and store the module based on that.  So you never have to worry about leaking into global scope.  There's no way to pollute or collide.  The only way is within the constructs of the file and the compiler will tell you maybe you didn't want to do that.
      So these are the premier code organization and reuse for the language.
      And the way that we can get a feeling for that is we define a module type, which is an interface for a module, and we basically say that we're going to define some add and define a type T and define an ad function and an implementation for floats.  So for an int, we're going to see that add is X plus Y and X plus dot Y, and this is where ints and floats are completely different types.  But doing this, we can see we have a very common interface, and I'll show you in a second.  But the bit that I want to show now is that much like Ruby, modules are actually mix interval and openable, which means they give us a nice tool for sharing code in different places.  So in this case, we have the module, which locally opens it all of the methods on the module available, but it does expose them outside of the module.  So if you use this module, the user's float module, they're only available locally.
      Similarly, we can use the include key word and take all of the properties and methods and values and types on it and actually make those valuable to the module and make those available to the consumers of the module.  So we have mixins and code sharing.  The other thing we have is that modules are first class citizens of the language.  You can actually pass them as values to functions.  And as I said before, files are just modules.  Which means you actually have first class files you can pass files to functions, which is a really interesting idea.
      But so what we've done here is we've defined a type, we've said that a monnoid is something that has a type T.  It has a value M empty, which is whatever the base value of the monnoid.  It takes two and squishes them together.  And then we define a function M append list.  And M append starting it with M empty and iterating the list.
      We have a little bit of type system trickery here.  We say that we have a type A, which is effectively like a A.  The way that module types work is that they're basically constrained inside the module.  They weren't leaked outside of the module scope.  So we cheat a little bit and we say we have type A, and I promise you the module that we're using is type A.  And I promise you the list that we're using is type A so the module and list type are exactly the same.  And that's enough for the compiler to say, yes, I can restrict this to things that obey that type.  So this is how we can write kind of general first class functions that have different behaviors, based on what we pass into them.
      So rather than having to write M append list for addition, multiplication, division, any of the operations we can perform, instead, we define M append list once for things that give us an M append and an M empty.  And then by defining things that are built the same way that M append -- the same way the interface is, we can just pass them into the function to produce new values on your functions.  So in this case for add, we sum the elements of the list and for multiply, we multiply the limits of the list.  So this is a very powerful feature.
      Finally, before I close up, we'll touch on module functors, this is a term that's pretty much loved by every programming language.  Functors.  A functor is from one category to another.  Mapping from one module to another, which is why they're named what they are.  They're not F map functors, they're taking an input module of a certain type and extending it and adding new code to it to return an output module of a certain type.  They're code generation facilities.  Similar to Haskell templates in C, generation in general.  So we can see that what we're actually going to do is we define a module functor that's a module, it has some type input, some type output, and it uses those to restrict what we're going to map between.  And then we define the functor itself, which is the make module.  And the make module just looks like a function; right?  It's a function of one thing that returns another thing.  When we're done with we end up with a new module that obeys the type of the app.
      So the first thing that I did when I learned about this, like anyone who has tried to use Haskell before, I thought, well, I'll write all of the Haskell type classes and functors.  That will be fun.  And you can get quite far.  There are a few things that you can't express easily.  But most of the time, functor, et cetera, you can get all of those out of this.
      So what I'm going to do is I'm going to describe how to write mappable.  And mappable is just the name we're going to use so you don't hear me say functor every five minutes.  We're going to avoid overloading that term.  We're going to basically say we define an input, which is type T of A and F map.  We define output, which is T of AF map and also generates the left F map functions out of the F map function.  And we can see that our implementation here takes the input F map and says it's just F map.  Don't worry about it.  And also says that left F map is just basically taking your F map function but applying const to it and applying a value.  So we say for every single thing that we F map over, don't return the thing that's inside the functor, don't return the thing that's inside the mappable, return this value.
      So what we want to define now, the interface or the implementation for a certain type to be considered mappable, we define a module, which is we do anonymously here, so we have mappable.make and next to mappable.make with we apply an anonymous module where we set type T to be option we define F map to be from nonto nonto some to some FX, and now we can use option.  And for free, we get the definition of left F map completely for free just because we know how to define F map.  We can generate all of the code here without needing to write it explicitly for every possible implementation of this type.
      So that's what we would use functors for as compared to module interfaces.
      The downside to reasons abstraction system at the moment is that it doesn't give us ad hoc or type classes.  What it means is we have to explicitly write functions that we want to pass these things into.  We also aren't able to escape scope, which means polymorphic modules don't behave quite the way that we would like them to.  There are two techniques to get around this.  One is available now.  Jerome and Liam white worked on papers, lightweight types, which exposes a way to use something called defunctionallization which returns modules, it's a whole thing, which I'm not going to go into, and you can use it now.  It's also actually available for flow and TypeScript from a guy named Julio, I believe, to have that same ability inside flow and TypeScript.  Really cool.
      The other way is same people are working on a newer OCml compiler, and that will give ad hoc polymorphism effectively to the language and allow you to use some of the same features.  A lot of the same benefits.  But until then, you end up having to use functors to mimic the generic implementation code in a lot of places.
      So one of the only puns in the presentation to take a reasonable approach, we basically for every single branch, every single logical branch, we test twice.  If you nest a logical branch, you test four times.  If you nest again, eight, and so on.  How many times in your code base do you write unit test that asserts the type of the inputs and output are valid?
      Worse than that.  You can only ever really test the things that you remember to test.  Unit test only exists when you remember to write them.  But you're then at the mercy of your memory.  At your tooling or of your time.  And as I said before, these are the things that tend to fall by the waste side when we're rushing, when we're pushing really hard.  And we never come back to them.
      Types cover many of the things that we write unit tests for.  And with a really powerful type system, you can push a lot of things up into the type system to cover that off.  They're faster than unit tests, and they run automatically.
      Reason was born of excitement.  It was born of excitement to introduce functional programming to Web development.  Was born of excitement teach new developers these ideas that they wouldn't have had introductions to otherwise.  And it was born of excitement to help give us these safe by default building blocks for the Web.
      The last couple of years in Web development have been years of tooling fatigue.  The weight and depth of the amount of information of tooling, of books, of conferences that you have to go to to be aware of just to be able to ship a production application.  If you think that the number of tutorials on the Internet is approaching too much, have a look for how many different ways that are to architect a Redux application.  It's really a lot of information out there.  Reason, instead, ships a rock-solid pragmatic approach to delivering a application, and it does so intending to improve the developer experience and to reduce the cognitive load.
      So what if instead of writing software the way we've been writing it for the moment, we push all of the complexity down below the language stack, we cut, and we give ourself some room to focus on the things that really matter.
      If this has been interesting, please come talk to me afterwards.  I would love to chat.  If anyone wants help getting set up, come find me.  I'm getting really good at setting it up.  Come engine the room, there's a lot of people in there.  And check out the starting guide on the website.  Basically, get started is about two minutes of work, so it's pretty easy to just get up and running.  And if you would like to get in touch with me, that's probably the best way to do it.  Thank you very much.
      [Applause]
      Captions provided by @chaselfrazier and @whitecoatcapxg.
