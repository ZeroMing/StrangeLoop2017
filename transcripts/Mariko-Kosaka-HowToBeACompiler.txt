      "How to *be* a Compiler."
      By: Mariko Kosaka.
      >> Awesome.  I think it's time, so I'm going to start.  Hello.  This is the session how to be a compiler.  My name is Mariko Kosaka, that's my Twitter handle pretty much everywhere on the Internet except my space.  If you want to try, you can find it.  It was taken when I registered it in '05, '06.  I flew in from New York City, I'm based in New York City.  I work at Google's Web developer relations team.  My job is to make you -- help you make better Web.  So if you have any concerns, complaints, things that you want to say to people who's making a browser, please do use me as a proxy to send those message and please do come talk to me.  And speaking of Web, I am primarily a JavaScript developer.  And when I'm not using JavaScript at work, I also like to knit.  That's my hobby.
      And when I learned to code, this hobby and work kind of married together, and I started doing everything with knitting and JavaScript.  So one of the example project that I do is thing called sweaterrify.  So if you like to have a visualization of ugly sweater using a loop, you can upload the image and then create a very realistic visualization.  This doesn't translate on the South Korean.  But if you go on the screen, I'm very proud of how realistic it is.  I spent a lot of hours looking at SVG to have this right type of shadow and right type of space for this in it.
      [Applause]
      Thank you.  But I started code when I already knew how to knit, and it became a thing that in order to learn to code, I make something for my other hobby, which is knit.  So the first thing I did was making a row counter.  My version was making row counter.  You know, state management, browser events, you know, saving local data.  Great.  Another one I did was color helper.  So if you do knit, and decided to color work, there's a common technique amongst knitter to take a black-and-white picture of yarn that you are going to use.  Because when you are making color work, you have to make sure that the color -- two colors you're using next to each other has a distinct contrast so that the pattern comes out and doesn't really blend it into mesh of black or dark green; right?
      So they do this technique of using the phone camera and then putting the black and white filters to define that.  Okay.  It's contrasted enough.  But if you've done work with color space, you know that's not true.  Like, the red and green might come out as the same black and white value while it's actually contrast color having look at the color in color; right?
      So, you know, that was fun project learning about color space in math.  And then next time went into image processing because I have this, like, one time where I was obsessed with printing out picture in knit ware.  So should you wish to have your cat on your sweater, then you have to do this interesting thing.  First of all, you have to have a very low resolution image because in the sweater, you probably have 80 pixel to 160 pixel as a width, depending on what kind of yarn you use.  And also, yarn doesn't come in hex code, so, you know.
      [Laughter]
      At most, you can use, like, six colors at a time.  So you have interesting challenge of using the noise, how do we do that by preverving the shape, a whole bunch of interesting thing I did and I made a library for that.  That was interesting.
      And then I went into compiler in DSL, and you were, like, that was kind of jump.  What the fuck is that?
      [Laughter]
      I promise it will make sense in a minute.  I'm going to go into it.
      So this talk is about alternative introduction to building compiler.  And I want to emphasize that it is alternate introduction.  So it is going to be introductory.  But also, it's alternate, so I am not going to be talking about visitor pattern, I'm not going to talk about the tools like LVM.  It's going to be explanation of compiler from the point of view of knitting person who try to make compiler for knitting.
      So visualization of my target audience is that if you feel like word compiler is, like, a black box where your code gets sent to and if they're bad, they're trapped forever and cannot come back.
      [Laughter]
      That was my understanding of compiler before going in.  Again, I'm a JavaScript developer.  Like, I literally deal with compilers, and I started dealing with compiler with Babel and things, and I was very intimidated.  But after this talk, I hope to change that perception by thinking a compiler is a box of fun.
      [Laughter]
      So now that the expectations are set, let's dive into it.
      So before talking about compilers, I need to explain to you what knitting is so that we are all on the same page.
      So when you want to make these beautiful sweaters, you go in, you download or buy a pattern.  In this case, I'm showing a free pattern that you can actually go download.  The knitting comes in two formats.  Either a graph or knitting pattern.  So graph is called knitting chart.  And this is what I grew up.  I grew up in Japan, a knitting pattern primarily use chart.  So I learned to read these chart and each symbol, and I can just dive in, look at the chart, and then start knitting.  However, I moved to the United States six years ago.  And here, we use a pattern, the written pattern, which is like this.
      And this is essentially a step-by-step word explanation of that chart that you just saw.  So it's two things are the same but they're presented in two different thing.  And I swear.  Every year, some programmer go home during holiday season, sit next to somebody who is knitting looking at the pattern and tweets that, oh, hey.  Knitting is like code and every time that happens, I get cc'd on the thread, and I'm, like.
      [Laughter]
      Listen.  I know.  Welcome to the club.
      [Laughter]
      So let's dive into what it looks like.  So if you do knit, then I hope you have a similar feeling that knitting is code.  But if you don't, then you will get it, hopefully.
      So even without knowing anything about knitting, if you are given this piece of text, I know you would think that this is a code.  You can see repeating word, like, K may be kind of like a variable.  And then more distinct one like until, remaining, or repeat from, which kind of indicates loop.
      So the knitting is a atomic unit for knitting is knit and Perl.  So when you knit, that means you are pulling the yarn from the back of the loop creating this heart-shaped chain together face of a fabric.  And then pull purl is creating this look.  And a combination of those two creates a beautiful pattern, usually.  There is, like, knit two together or make one, a combination.  But atomic unit is just knit or purl.  So if you go look into your sweater -- so the left one is a two by two ribbing, which is very common in your cuff of the sweater or neckline is basically knit, knit, purl, purl repeating all the way up.  And then the next one that looks a little bit more intricate if you look at it, it is just a knit, purl, purl, purl purl purl, creating these patterns.  So that the base of knitting.
      So let's dive into this knit, and I'm a JavaScript developer, so I'm going to show you a JavaScript code, and you will understand why I write JavaScript because it's so good for knitting.  I will explain that later.
      [Laughter]
      But when you think about knitting as a code and try to write a computer code that the browser understands, it is essentially a laymen manipulation, so let's see row by row.  So first one is co5, which is cast on five, which means put -- let's say this is the knitting needle.  Put five loops on the needle.  So basically create my scarf, the parent array and then create in the array row zero, which is five and then you push that into the scarf.
      So this is basically, you know, you have five stitches on your needle to start.
      Next one is row one knit.  And when the pattern just says knit, that means knit however many that you have on the needle, just make that knit stitch for it.  So the row one is map of row zero to create this KSTS.  KSTS is stitches in knitting speak, I guess, in connection with common abbreviations.  So now I can create a row one that has a string -- five of them because the low zero was five.
      Next one is a little -- oh, so this is how it looks like in the real life.  The next one is a little bit more complicated, and you can't really solve it with map because there's so many things going on.
      So let's do one by one.
      Row two in knitting, you can't create a magic number -- well, magic stitches immediately.  You always inherit the size of the previous array.  So you create a new array because it's on the needle; right?  Like, you can't, like, go from ten stitches to 100 stitches immediately.  There will be instruction if that's needed.
      So there's no instruction to create a new stitches.  So we'll just include the sides from the previous array and create a row two array and then keep the index.  And the first one is K2, which means knit two.  So, you know, just push the letter K to the first two elements of this array.  The next one M1 is make one.
      So the M stands for make.  Which, basically, means here please create one stitch.  That didn't exist but please create it.  And there's many ways to create it.  But, usually, you pick the stitch from the down.  But in the array, it's kind of like a splice in changing the lens.
      And you start to see that JavaScript, the best language to do this because you are manipulating the size of array and checking the size of array as you go around.
      I learned C++ -- I went to C++ class six months ago, and I learned new syntax, and I was, like, I'm a programmer, I know the syntax, I'm going to port this knitting program into C++.  And first question I came up to instructor was how do I know links an array?  And how do I change that size of the array?  And the instructor was, like, yeah, about that.
      [Laughter]
      I now know how memory allocation works in JavaScript.
      So the next one, now that we change the size of an array, next one is knit until two stitches remaining, which means until the two empty elements left in the array just put knit stitch into that array.
      So in this case, it's only adding one knit stitch.  But then still remains in six and there is two empty element in this array.
      And comes M1 again, so now we're changing the size of our array again.  Now the size of an array is seven.  And then the last one is knit two, filling in those things.
      So at the end of this procedure, my scarf array has the three lows of starting with nothing of five to knit five to knit seven.
      And lastly, so start with these tiny operations, and then lastly you repeat it for 20 times, and then you start to get shape of scarf.
      You might guess that this operation, if you continue to do it for 100 times or 200 times, you would get triangular scarf.  However, when you deal with knitting, you can see a little bit on this picture that it's carved, like, making the carve, you get to deal with hyperbolic geometry.  Knitting is not a space, but hyperbolic space.  I still don't have the answer for it, but I do want to make this knitting visualizer that translates a knitting pattern into actual visualized thing.  And if you know how to deal with hyperbolic geometry on the 2D Canvas, please do let me know because my math understanding is not quite there yet.
      So what -- why does this lead to compiler in DSL, the domain-specific language?  So I was -- when I started learning code, I immediately went into understanding knitting with code.  Three summers ago, I took a little challenge of going to a little uncomfortable area of trying to explore this as the artistic thing that I do.  And I enrolled in this program called school for poetic computation.  It's a school in New York City where programmers and artists get to go for certain amount of time.  I went for a period of time.  But there's a ten-week program.  And, basically, it's a place you get to do fun shit with code and art.
      In there, I took a class by Sarah who spoke yesterday here called talking to machines, those assholes.  And it was basically a class to explore programming language that talks to computer as a artistic medium.
      So we learned a lot about specific language and how to make those things and parser, deal in parsers and looking the tooling machine and, you know, a lot of things.
      So my project for this class was that, oh, I've been thinking about knitting with code, you know?  Looking from, like, how to see knitting from the computer's point of view.  But what if I can make a knitting point of view exposed into computer?  So I made a small programming language called 64 stitches.  And idea was to treat a knitting pattern that we just deciphered was JavaScript as a computer code.
      So you might see in the thing the CO8, cast on eight until stitches.  You can kind of change, and I made it interactive to change the pattern as you change those values in the code.
      My graphical programming skill was not quite there yet back then, so I decided to do a underscore and star as a -- the replacement for knit and purl stitch to present the color difference not be fabric difference.
      The visualization for the sweater pattern came a year later.  So now, I can make almost realistic presentation of knitting fabric.  But back then, I just used color.  So underscore represents white pixel.  The asterisk represents a black pixel.
      So I tweeted -- good thing about this is that the entire code fits in the URL, so a lot of people started tweeting me their code in the URL form, and I made a little bit of, like, a visualizer, so here is the invader that they made.  And skull and cat.
      So a lot of people got the idea that the cast on is -- defines the width of this pattern.  But not many people got into this loop action of the programming language that I defined.  A lot of them ended up just defining one by one pixel of the color, which is fine.  Kind of interesting.
      So I use PEG.JS to make this project.  PEG.JS is a parser generator for JavaScript, it's to generate a parser or compiler using a thing called parsing expression grammar.  And entire code for doing this 64 stitches looks like this with a little bit of JavaScript outside of this page.
      So it was, you know, it was, like, a little bit of trying to learn how to do this expression.  But it's kind of amazing that these tiny bit of code can spit out a parser that suppose a very small programming language.
      That was interesting.  However, I'm pretty much in the school of thinking that abstraction is a tool, not magic, and you have to learn it to use it.
      So even though I had this interesting experience of or amazing experience of being able to create a domain-specific language for knitting, I was very frustrated that I did not understand what goes into it.  I felt like somebody told me -- yeah, just that works as is and just accept it as is.  And I know there is many people who teach programming tell beginners that, you know, just abstraction is amazing, just, you know, don't question it and use it and just will you get there later?
      I'm the kind of person who have to understand what those abstraction is step by step in order to use the abstraction.  Once I understand how jQuery works, I'm, like, just use jQuery everywhere.  But once I understand it, I have to write a DOM code by myself.
      I'm just that type of person.
      So it got me into kind of backing idea of I want to make compilers, I want to make this, you know, understand how to make programming language.  At work, also, back then I worked at a company called scripto that made a text editor for TV production.  So TV producers and writers use specific grammar to specify characters in scenes, and I could have just been doing making a React component and doing the UI part.  But because I was mainly interested, I volunteered to do converter of converting the specific into back then I didn't know what ASD is, so I was calling a structured data, and then from there you can convert it into rich text or some other format.
      So a year ago almost my comment to work Slack that my common code has function lexer and parser, and I was thinking this sounds like a computer science.  Maybe I'm a programming computer.  So you can see a year ago my understanding was that.
      I was with a lot of blog posts and compilers, but I wasn't quite there yet.
      But I listened to a podcast interview by a guy named Rui, and there they were talking about a project that Rui did, which is how to host a C compiler in 40 days.  And the interview goes -- it's kind of amazing that you made a C compiler.  Like, how the hell did you start it?  And he goes in with, like, well, if you think about it, the language specification for C is very set and very minimal, compared to other language.  And, you know, you just start with day one creating a string of -- a string expressions and another little and next day you add another operators and one by one, you add a feature to the C language and, you know, after 40 days, you get a self-compiling C code.
      And I was, like, okay.  That is the interesting approach.  Maybe I might be looking at this project wrong of thinking that I have to understand this compiler thing in order to make a programming language or the parser.  Maybe this feeling, I should start with tiny corner and just, like, start doing it.
      Coincidentally, I discovered a book called Design by Numbers, which is written by John Maeda.  Design by Numbers is the name of the book but also name of the programming language developed at a MIT media lab back in '80s, '90s.  It is precursor to processing, and it is designed to teach a philosophy nuts and bolts of how programming works to artists.
      So the code for DBN, design by number looks like this.  Like, zero pin 100 line zero 100, 100.  And then the output of that code, the compile results of that code is that image next to it.
      The book is beautiful.  Book go through one by one the first idea of what is color?  What is pin?  What is it like to put dots on the screen to what it's like to store data in a variable.  To what it's like having loops, so you can create 100 different versions of this image.  And if you go cover to cover, you kind of understand the evolution of creating a programming language, much like the guy who created the C compiler, self-compiling C, you know, it was very tiny thing into --
      So I was, like, this is interesting.  I went into websites to see if there's any more resources.  Great thing.  The newer version of DBN came out in 2003 that supports a browser that you can land in code.  So I went and clicked and, of course, it's Java-based, so it doesn't work.
      I wasn't too keen on compiling Java source coder myself, so I was, like, I know a programming language or the language that does this that works in modern browser, which is SVG.
      Could I -- maybe this is a good chance that I start making my own compiler that takes a syntax that is well-defined in the book designed by numbers into a SVG?
      After all, compiler is, like, taking a source code, doing something, and outputting it.  While I was leading the book, I was taking a written code, thinking myself what it would look like, and then imagining the picture that would come out.  So, basically, I was being compiler, so how can I make that into code?
      So let's do a little experiment of being a compiler.
      So the precursor information that in DBN, the space is always 100 by 100.  The corner, bottom left corner is 0, 0, and then top right corner is 100, 100.  Color is defined from 0 to 100.  0 is white.  Black is 100.  There's no other color.
      Let's see.  This code and think about what kind of graphic this code will produce.  And this is the exercise that I did of thinking about, you know, I just did this by reading this book.  What just happened?  Let's just do it again.
      And yes?  Yes?  Okay.
      If you guess this one, then congratulations you just became a compiler.
      [Laughter]
      Let's see what went into your brain by doing so.
      So you were given this piece of code, the string that you somehow understand the rule of the programming language, like, colors and space.  First thing you did, probably, is to define that.  Okay.  Distinguish the word and number, so you divide those things, and then you classify those as a word or number.  After that, given the programming rule that I told you about the paper has a size and the color, you probably started to group those together, thinking that.  Okay.  After paper, there is a color number.  So those are two -- one chunk.  After pen, there's always a color, so there's another chunk.  And then after line instruction, maybe there's X, Y coordinate for two points to draw.  So those are one chunk.  So you started to group those things together.
      And after that, you probably change that in your head into human readable language.  Like, get white paper or white rectangle and black pen and draw a line in the middle 50/50 of the Y coordinate from left side X0 to right side X100.
      And compile result is this.
      So you just compiled it.  You draw it.  This is kind of like executable that you get after compiling C code.  You can give it to anybody.  And everybody would say, yes, there is a straight line in the middle.  They don't care about what kind of code that produced.  But you can share those things, and everybody will get the same result.
      So those are the compiled results.
      And we just did a step that compiler takes.  We just did chunking into tokens, creating a structure, changing the shape of that structure, and outputting a code.
      So let's look at it in computer speak in order to make this compiler that I was trying to make, which is taking DBN syntax and then outputting a SVG.
      So the first thing that happened is tokennization, and this is the only section of the talk that happens computer the key word.
      So sometimes it's called lexical analyzer.  You get a string, paper 100, and then you output things.  That's, like, a little more divided and classified.  So in this case, I basically split -- do the split operation with space.  And then check if it's number or not, and then classify as a word or paper.  So that's what we were doing on the side shows what we just looked at.
      And after you have those things, you do a thing called parsing.  And when you do parsing, you create a thing called abstract syntaxry or AST, for short.  AST is like map of your code.
      So let's say by defining things, you now have a point on the map that says here's a city, here's a station, here's your house, and, you know, here's something else.  And by creating AST, you map those points and how those points connect together by a load.  So you start to draw the map of your code.
      Is, again, you have those input, and you pass into parser function, and you would probably create a structure data that looks like this.
      So in this case, I start with a drawing as a big type.  And inside of the drawing, I have a call expression of paper.  Paper takes arguments of type number.  And in this case, value is 100 or in the picture example, it's zero.
      And then, once you have that, much like we change it into human readable code -- text, you do things called transformation.  So transformation is creating a new AST.  So in this case, in DVN sphere, ideal paper exists.  Ideal pen exists.  However, in order to put those into SVG world, SVG doesn't know what paper is or pen is.  Maybe they have similar understanding that is that it is a path or color or rectangle.  But you need to translate those things in order to make SVG.  So you give those data and then create a new AST that's more suitable for the world.  So I straight up defined target SVG has the element of the rectangle, and that has the attributes, and then finally -- so this is what you did was, you know, changing into human readable code or human readable text.
      And then finally, you do code generation, which is creating actual SVG element.
      So, you know, again, you take that new AST, go through that structure, and then just, you know, string concatenate, make SVG code.
      So here is a demo that if you are interested, I have a demo online that has a kind of like a -- and you can edit it, and you can see step by step tokennization what happened parsing AST and transform the AST to see what happened and if something that they don't understand happens.  And that's on my GitHub/SBN.  I named it SBN, like, SVG by numbers only designed by numbers.
      So if you want to look at those and kind of, like, you know, on the fingertip understands, you can look at that.
      So by making compiler is really fun and I recommend everybody to do it.  And here's a few suggestions that you can do.
      So we write -- well, I write JavaScript.  Some of you might write JavaScript.  But maybe you can write a compiler that takes a JavaScript code -- well, that takes a different code and spits out JavaScript.
      Maybe like Japanese script.  So this is something I care a lot, so I -- English is my second language, and I damn know that having a privilege of time and money to learn English granted me a lot more opportunity in this industry.
      You know, it got me able to lead leading edge technology without waiting for somebody's translations.  It got me to write code proposal for this conference, which got me more visibility in the community.  You know, when we talk about code, and we talk about coding is universal, everybody should learn to code, you have to realize that the language itself you're using code, like, function and if and while is English.  Entire ecosystem is egocentric.  Maybe 7-year-old in the United States might create a JavaScript code easily to do something awesome.  But then in some same 7-year-old in Japan might have, you know, stumbled upon this idea of what is if?  What is while?  And have to wait to understand those English grammar first to get it into computer programming.
      So those are something that I really care about, so maybe you can do those things.
      There is a thing called Fikascript, which lets you write JavaScript in Swedish and vice versa.  So it's possible if you want to do it for your native language.
      But not only that, you can do things like emojicode.  Write a code in emoji.  That's awesome.  And another one is Piet.  So Piet is a programming language that uses the code is picture.  So the alignment of the color defines what kind of operation this code needs to do.  And it's not just an art project, even though it is weird and fun and arty.  When you deal with DB -- kind of lake a WebGL and try to do a math on WebGL, you do load data in color because, you know, DB understand image, image is data, data can be scored in the image, and you can do weird things.  So image as a code is a valid thing.
      So in conclusion, I suggest that we should all make compiler, even though you may not have a project immediately, you should try.  Because you learn a lot of things from just building a compiler.  And here's three things I learned after a building a compiler.
      I'm not saying, like, the computer tells you everything.  I don't believe in, like, AI as a god.  But you do get to learn a lot of things and learn from computers sometimes.
      First thing is it's okay to start small and have unfamiliar things.  So much like lexical analyzer started was just dividing up the code and just classify is it word or number?  They didn't need to know what happens in the next step, but they just started with very small thing.  And, you know, let the other step worry about it.
      So it's okay.  To start with small, unfamiliar things.  Just start it.
      Another one is be a good parser.  Don't be jerk with bad error message.  And it's not just code that you write but also the human interaction.
      So I learned computer programming with a lot of people's help.  Like, I came in, I did basic syntax, but then I learned a lot of things by asking questions.  And a lot of helpful answers I get is not the answer that I get about the things I asked.  It's the thing, the pointer to something else.  So let's say I examine.  Like, I don't know why this doesn't work X.  Unhelpful error message or unhelpful message is, like, yeah, I think it doesn't work.  Yeah, that's wrong.
      That's not helpful.  But you don't need to solve the problem for me, but you can say something, like, well, that's -- that wouldn't work.  Maybe you should look up these key word on Google or you should look up this documentation.  Like, a little bit of pointer to get started.
      Elm is a language that kind of embraced that methodology, and there's a great blog post about compilers for humans.  If you write Elm, you know when Elm throws an error, it says it's an error.  But you might want to look up those things.  This might be wrong.  You might want to look up those things.  And it's very helpful.
      So you should write those error messages in your code, and you should be like the error message when somebody asks you question.
      Lastly, the context is everything.  So much like our transformer transform the information that was suited for DBN world into SVG world, you need to switch the context when we're making things.  When we're making software, maybe what you build now for U.S. market might not work for your Asia market, and you need to find somebody who is really good at transforming those context.  And those are really good people to have on your team because it makes your production code so much easier to write.  They are the one who translates everything that you need to know.
      So be careful of the context and be awesome compiler.
      If you are interested in the thing that I talked about, I have a blog post about what I did with JavaScript code sample.  So do look at this.  It is essay.  So if you want to translate those things to a different language, you can totally do that and ping me that you did it, and I will link to it.  You can use your blog, you can use the GitHub.  This is the latest one, the Brazilian Portuguese the volunteers did.  And right now, it's translated into five different languages.  So if you do speak other language, please do help me.  And thank you very much for your kind attention.
      [Applause]
      Captions provided by @chaselfrazier and @whitecoatcapxg.
