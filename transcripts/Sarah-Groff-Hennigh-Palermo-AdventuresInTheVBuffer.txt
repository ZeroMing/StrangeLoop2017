      "Adventures in the vBuffer."
      By: Sarah Groff Hennigh-Palermo.
      >> Hi, everybody.  All right.  So it's 1:00, so I'm going to get started.  So just to let you know, my name is Sarah Groff Hennigh-Palermo, that's a lot of names.  I feel like if it's good enough for royalty, it's good enough for me.  You can find me online usually as SarahGP or SarahGHP.  I'm on Twitter, it's super SGP.  If you like this talk, feel free to tweet about it, if you don't workers' compensation don't tweet about it.  If you want to follow along with the slides, especially some of the code slides, there's just a PDF there.  And the examples I'm talking about are also on GitHub at worst-cat.  That's a very funny tumbler that I stole for the repo for this project so after the talk if you want to see things on your own machine, feel free to head over there.
      So a little bit about me, I'm an engineer at Kickstarter.  There's a whole bunch of Kickstarter people here too.  Thanks for coming, guys.  And in my spare time, I like to make digital art and today I'm here in both roles as an engineer and artist.  And this is a long adventure that I took from being a designer who kind of admired digital esthetics and the way we could use art in code.  To help those both artistically and engineering-wise to answer those questions myself.  And in some ways, that adventure started when I spoke here at Strange Loop three years ago about data art in JavaScript.  I still have the same haircut, so some things I'm doing right.
      And I talked a little bit about the why I thought the work that other people were doing was really amazing and vital.  And then I went to the school for poetic computation to the recurs center, I got a master's degree all to get myself to doing the kind of work that I really admired.  And along the way, I've taken a number of self-directed accidental quests and journeys.  And so today, I'm going to tell you about one of them.
      And this adventure took me through investigations into the kind of differs that power things through Elm and React, through the basics of WebGL, through basics of about, performance, mostly in Chrome, and then immutability both in JavaScript libraries and in Clojure script.  And all of these were done in the pursuit of art and art making.  And I think this is really important for two reasons.  The first is that when you're an artist, you're not always an expert.  You're trying to make this thing that you want with the tools that you have, and that can make a really interesting experience working with code, you know?  You're not doing work for money.  You're not doing stuff that has to work under some definition of, like, people come to your website, and, you know, expect your forum not to crash.  That really gives you a lot of freedom to do things counterintuitively and to find out new stuff, and it can be a really fun adventure.
      And so to respect that spirit of adventure, today's talk is going to be in the form of an adventure story.  Where we'll follow our hero who follows a resemblance of me, and she's going to have seekers of the V DOM, there's some friendly ghosts and witches along the way.  Final, she'll meet the garbage collectors and the wise old lady who will probably know everything at the end.
      In her quest to write fast and cool graphics programs using the latest in JavaScript tech.
      So now we're going to join in on our adventures in the vBuffer.  All of the illustrations that are really cute are done by my friend Emily Griffin.  She's Emilywithcurls on Twitter.  She's great, I'm excited to share our fun slides with you guys.  So please give her credit too.
      So as all adventures do, ours begin with a heron with discontent.  She's part of the group responsible for hardware-accelerated painting.  And she has known since she is small that WebGL is an API for drawing on Canvas elements.  It uses the graphics card in the same way that games do to make hardware-accelerated drawings.  It uses an API very similar to open GL, which is how non-Web graphics programming happens.  And these can all be a little bit mysterious.  I'm sure they look very mysterious.  And our heron.  In particular its parallel processing means a lot of threads do lots of calculations all at once but to keep them going, you have to talk to them in a particular way.  And here at the beginning of our tale, the full workings of GL are still somewhat mysterious.  She does, however, have a vision of the standard work of GL work.  It looks kind of like this.  Or maybe like this.
      Or sometimes it even looks like this.
      And while the math is amazing and hard and the art can be really great, it's just not our heron is that he can't.  She wants to make things like these generative sand creatures but maybe, like, 10,000 of them.  Or something like these really cool forms made by Zack Lieberman who is my teacher and doing amazing stuff with 3D work.  Or might say what would the paper look like or some Olga rosenova.  But, like, 10,000 and animated.
      And she's been starting slow, messing around with things, like, some simple lines that interpolate the colors here.  And some box lodges, and sometimes happens, you know, in any given and why not just build this in SVG, if that's what you want?
      And, you know, she says but certain things are really difficult to impossible with SVG, even though we don't always think of WebGL as being 2D.  So the color interpolation on these brownian lines is incredibly difficult to do on SVG but incredibly easy on WebGL or add all of these pixilated architectures to cubes.  Much, much easier to do using GL.
      So why not make something that she wants?  Why not find a way to make something that's nice and fast, that does not have as many weird, incantations, that we can do without thinking about global state so much, and something where we can use a really cool decorative syntax that we have on the right where instead of managing buffers or the way computer understands memory, we can just say here's my data, now, please draw it every x-number of times.
      So this is the goal, and this is what she wants to find, but these questions aren't being answered by staying here in WebGL where everybody did things the same old ways.  So instead, our heroian packs up her dreams and finds out the best way to build her country.  One must seek previous adventures and scraps of wisdom.  And really, where is it different?
      And so she's had sets out, after traveling some time across the plain, she first encounters a group that she has heard praised but never seen.  Made speed out of distinction, and she asked if they will help her.  The differs multiply from two to 200 and begin to confer among themselves.  Chatting and trying to convince one another.  Sitting when they are unwilling to change their minds again and finally back into two with a stable decision.  Yes.  And so they reveal to her the V DOM.  This is a strange machine.  It works much like the differs themselves had worked.  Taking in data computing, and then reaching out and changing the world once they have their final answer.  In its work, it seeks to answer this question.
      Given two versions of the DOM, what is the smallest change that can reflect the new truth?
      Because accessing and changing the DOM can be slower than comparing two JavaScript objects, a V DOM works by creating a virtual representation of each state in JavaScript.
      Then when a set of changes comes down the pike, the differs find the smallest change that can reflect that new truth.  And usually the path looks something like this.  We start off with an initial tree, changes happen, and a new tree is created with those changes.  The trees are then compared and a list of patches is generated from the comparison.
      The list of patches is applied to the DOM, and the initial tree is replaced with what was the new tree in this cycle, and it all starts over again.  So let's talk a little bit about creating a tree.  The data and the tree is usually an atomic representation of the system we're virtualizing.  So in this case of the DOM, that would be something like an element node.  In this case, an H1.  Element nodes can have children, et cetera.  It's the DOM node you're probably most familiar with.
      Sometimes you can have something even more basic like text, which is a node type, but it's much less complex, so it's nice to pull it out for itself.
      However, there's a third type of data that differs really like to leverage.  And that's the thunk.  And so this is a concept that's often used and two slightly different but interrelated ways, and it's delayed evaluation.  And sometimes delayed evaluation thinking a thunk is a function that is memorizable, which means once it is valuated, it doesn't not to be evaluated again.
      It is what you are creating when you write a custom function.  That's because otherwise React is testing whether things are the same just by checking the object reference.  Are they literally the same object?
      And we'll at this a little bit more in a second.
      A function of the second type, a memorizable function is usually a peer function, which I know you are all at Strange Loop, so you know this.  But it's a function whose output relies only on the arguments pass to it.  And one of the best parts about this pure thunk is that you can just chair the arguments, which means you only have to compare smaller pieces.  And so both approaches attack the central problem of diffing, which is to say when to rerender?
      Comparison is costly and the only way to sort of completely know that the content of a data structure has changed is to iterate through all of that content.
      And so a data chunk that can tell you whether to rerender or one that allows you to compare smaller units are the keys to the differ's magic.
      Now, will this same montage work for our heroian for WebGL?  The differs do not know.  They only know about the DOM.  So she must go on further to find out how the GL incantations work.  So our heroian walks into the dark wood.  Night comes things get darker and darker and Gothier and Gothier until finally she arrives at a clearing with a fork.  Each path from here seems to delve into one connotation of what people mean when they talk about WebGL.  So the left is the best warn path, and she can see through the trees, meshes, camera, lights, scene graphs.  There's even a cozy A-frame off in the distance.  This is GL as a way to create three-dimensional worlds and objects.  And it's cozy, it's replete, it's full of libraries.  This seems really nice, but it's not necessarily what we want.  To the right, the path leads into the tight thickened, out of which sparks lines and really trick equations seem to come zooming.
      This must be the shaders.  Our heroian has heard of these shaders that they can make weird art very quickly.  But apparently their magic is strange.  The programs operate on each pixel very quickly but only alone.  They have no knowledge of the world, no history, no sense of the future.  That seems maybe too weird.  She would probably end up like that raven guy.  Instead, ducking an errant equation, she heads forward and appears to dead end into boulders.  It's dark, and our heroian is tired.  She lies by the boulders to cook up hot dogs.  Or I guess it just solved itself packed into one hot dog.  Damn.
      Chomping away, our heroian noises there may be drawings on the rocks.  She grabs her flashlight and heads out to store.  And there lies the GL pipeline revealed, finally.  Behold.  Graphics are made in the following way:
      The user starts by designing a set of triangles, which when combined together form more complex objects.  This combination is called the mesh.
      Each triangle has three vertices and each vertex has information attached to it.  Its position, its color, text coordinates, et cetera, it can hold a number of arbitrary pieces of information at any given time.
      And then, these are sent via the drop call to the vertex shader.  Which manipulates the described objects in a scene eventually setting the vertcy's location.
      Often, this involves multiplying location values by a matrix uniform, which is made prior to the drop call.  And this is the sort of matrixcies.  Sometimes called a rosterrizer or tumbler, and this changes the value from theoretical spaces into pixels that are on your screen.  If a type of variable called a varying variable has been provided to the shareds, this rosterrizer also interpolates the values for that variable.  So, for instance, for a gradient, each vertex might have one color given to it.  And then the varying variable will calculate all of the in turn colors you would get on your triangle.  Now we have pixels.  And these go to the fragment shader, which determines the final color of a pixel using its location and uniforms.  And this is where those crazy partyiers when people are, like, I coated up all of these crazy shaders, man.  This is sort of where they're doing their thing is in the fragrant shader.  A lot of times they draw a rectangle and then a trick to draw your crazy fractal shaders.
      So in the code getting everything to the pipeline before this happens looks kind of like this.  You initialize the Canvas and get a context, and then you set global state flags, you have to make a program, and then you tell it about the shareds you need, and then you get the locations for all of your data, which you're going to need in a minute, you generate your data, you tell GL where to find your shaders, you set the attribute in uniform locations.  Remember we saved those a few steps ago, and then you tell it how to index into all of the information you gave it, you compute your metrics, set your makes, you draw your element, and then if you want it to turn, you draw all of that into an animation column, and that's it.
      [Laughter]
      That's, like, super easy.  All you have to do to animate a single cube.  It's great.
      So looking at all of these calls, one thing that may jump out at you that I want to address really quickly is they're very procedural, and you're usually using a single WebGL object.  So why not set everything on the object all at once, you might say?  Well, because the GL context is used by a number of programs on your computer, there's sort of no guarantees about what context it's going to be indexing into at any given time.  You could lose it, and then you're going to get a bunch of errors, so you mostly have to go through step by step to be sure that you are in your right context.
      So instead, we're here binding, sending data to the GPU and then rebinding and making new calls when the data changes.  So, for instance, if you have position data, you bind that in, send it, and now you have new position data you need to rebind it and resend it.
      And why is that?  That's because WebGL is very -- is, like, the granddaddy of global state.  And so any time you're working with an array buffer, there's one array buffer that GL is working on at a given time.  And you have to be, like, no.  No.  Now we're talking about this other thing that I told you about before.
      So it's a lot of code and a lot of state to keep straight.  It occurs to our heroian that this whole V DOM thing might be adapted to V buffers.  Maybe that would be really cool.  So she sits down and begins to put things together.  Hammering and sawing, she assembles her V DOM buffer and begins the test example.  It has two cube geometries.  A traditional cube and sliced up one.  And this is to test the effects.  Creating the case for regenerating a matrix and then rebinding that matrix euphemism each frame.  So in WebGL, we create the object and then the way you can appear to see it is based on our matrix.
      And it represents its data in objects for each type now, so these contain the type of data that it is, its shader variable, and then as well as a name, so we can see that the positions use the shame shader variable.  It's always the position, but the names are useful inside our renderer.  And then we have our data and the pointer.  And the pointer is all the information GL needs to read the data to come out.  Every vertex has three pieces with it, et cetera.
      And then the animation function just assembles these objects and mutations together and shoots them over to the renderer.  The rendering function.  This is the vBuffer differ.  The core of the project.  And this is how it works.  So a component comes in and if it's a draw call, we always run it through and call it.  That's sort of how you measure when WebGL is going to call your next view.  Otherwise, if it's new, we get an enable location, and then go through to bind and set the buffer and uniform and save a new tree.  If it's not new, the question becomes, well, has it changed?  And if it hasn't, then yay.  We're done.  We don't have to do anything.  If it has changed, then we go back to the binding and setting the buffer because we already have its location, and then it goes into the new tree.
      In this case, the differ uses the component name as the key for the vBuffer representation, and so if it doesn't exist, it gets the element going to the location and saving that copy in the vBuffer for the next round.  When the key does exist, the question becomes whether the data has changed.  Fortunately, Lodash, which she packed away to bring with her, has a nice equality check, which is equal, so our heroian doesn't have to think what it means.  Win, win.  She begins to run the program.  One cube.  Looks good.  Ten cubes.  Still nice and smooth.  100 cubes.  They're looking good.  1,000, you know.  And then 3,000, this one's 3,000.  It's kind of slow.  1,000 was okay.  They aren't spinning so fast.  But why?  This is a big problem.  Our heroian can see into the art itself, but she doesn't really know what's going on underneath.  How can she figure out what's wrong?  She sits down to give a really good think to things and properly falls asleep.  No wonder.  This has taken days.  And when she wakes again, it's twilight.
      Everything is still, the fragment fairies seem to have slowed down or maybe they disappeared.  Not everything is still after all.  The bushes seem to be shaking.  Our heroian just saw some glowing eyes or maybe a paw.  A package comes out from the bush creatures and there's a note.  Hold this over your box, and sho she does.  Count down appears.  Four, three, two, one, and it's replaced by this.  A view into the box.  Or maybe it's the performance tab on Chrome.
      So the way this works is these red bits up at the top let us zero in on our slow frames.  In this case, every frame is a slow frame.  A slow frame is anything that runs under 20 frames per second, which is 60 milliseconds per frame.  And a film runs at about 23 films per second, just for context.  And we can see which frames are the slow frames.  So up at the top right there, there's that little red marker on them in the candle chart and when you click on that, you can either scroll down and see the spots that are taking long because they have very wide run times, or we can look at the very bottom Payne here, which lists the function themselves.  It's also possible to view while the functioning is running.  This is a little bit hidden but if you go into Chrome and type rendering into the command menu, a screen will come up, and you can pick it, it's really helpful.
      And so in this other view, these are -- this is our view of all the functions now just sort of pulled up.  Anything that has a very high self time is a function that is itself slow.  And in this case, it's a bunch of Lodash functions.  Probably because deep comparison is expensive, but it's hard to know when it's inside a library, and you can't really change libraries, especially when you're trying to make art and not necessarily start opening PRs on open source projects.
      So the next step may be to see what happens if we go library free, which our heroian does.  She strips all the Lodash from her code, bangs a few things around, hits play, and nothing happens.  She holds up the performance window but nope.  It has no insights this time.  This stupid must be cursed, she realizes.  Noticed some cuts marked out of the folders specifically absent until now, our heroian climbs over the outcropping and marches away on the path.  Sitting there getting angrier and angrier lost in her mind about this bug an hour later.  In fact, she's so angry, she nearly bulls over a woman in a hat with witch which on the hat.  Who are you?  This, of course, is the reference witch.  She can tell you which is which and what is what.  But until our heroian explains that the example is broken.  The reference which holds it, turning it slowly until the problem is revealed.  You're never copying the object as you pass it through the differs reconciliation pipeline, she points out.  Lodash must have been copying it for you before.  That means as soon as you update it here, it's updated at the end.  And if it's always compared to itself, new data is never sent to the buffer.  You don't want to test if they're the same object, she laughs, only if the data has changed.
      The witch disappears the sample a few times, causes it to omit objects when the data changes.  These are then copied to the vBuffer.  So now it goes review the element.  If it's new, create a copy using object auto sign.  Make the binding in drop calls like we did before, and then update the old tree with new elements copying those over again.  This works to make sure that we are copying them all the way through because if you have a reference, you're copying them because if you have a reference deep inside a object, and you copy the object, the reference is still inside there in the same.
      And so this is quite a bit faster.  1,000 is smooth, 3,000 is still looking good.  It's a little blocky.  5,000 I mean, this looks roughly like 1,000 did before with Lodash.  And even 10,000, still moving.  But since this is all of our code, what could be causing the problem until now?  What's the bottleneck we're hitting at 10,000?  We grab our frame again.  Countdown four, three, two, one, and end back up in the summary tab.  Here we notice that there's actually a link to the line of code that's been identified as being the problematic piece of code.  So we can click through, and it turns out that now we can see the execution times for various lines of our code over there in the left.
      And one thing that's weird is the line that we were originally linked to down here 219, that's not actually what was taking forever but now that we're in here, we can take a look and find out that most of the execution time occurs when we're doing the mapping to generate the values for the new matrix, and that makes sense.  You know, as the number of values of arrays increases, you have to do more work.  And she decides to check the reconciler.  And here a lot of time is spent in the main function that goes through each data piece, and that includes the attribute effects that we're changing, so it would make sense that it's taking a lot of the time.  And we can dig into which subfunction.  So that has not changed.  That makes sense.  And then deep inside has not changed, it becomes apparent that it is the content comparison that's taking a lot of time.  That's what this array is.
      So the second most time arises every time we diff and check.  But, of course, that's all we have left once we have broken the line of references.  The research which is familiar with the problem but sadly, she cannot help.  My magic is a little bit limited, she size.  But she has a tell of even stronger magic.  Adaptable and changing in those who charge its secrets.  Facing one another across a chasm.  They are mostly similar but slightly different.  They don't care much for my kind up there on the immutable amountable, she says.  The climb will be grueling, but that's where you want to go.  Our heroian plunky and strong from the sandwiches makes the climb.  As she comes around the two castles, she says one is on her side of the road and the other across the reveen, as she was told.  A broken bridge is halfway across.  Our heroian knows where to start.  Immutable JS is across the castle, which seems to be inhabited by friendly can ghosts.  There they are waving from the windows.  They welcome our heroian in and of course the keepers are ghosts.  After all, they never change.  They then begin to explain how to adapt the experiment.  We don't use plane objects, they explain.  We turn them into maps.  And we don't use dot syntax, we use get and set.  This JavaScript is strange and arcane and our heroian has not seen these smells before.  So the friendly ghosts aoblige.  You see, whenever you you change the contents of a data structure, you're actually making a copy.  You may keep the name the same, the identity, but instead of mutating the structure, you're just making a new copy.  But because actually making new copies would take forever, we use a persistent data structure that uses structural sharing to make fast copies.
      Persistent data structures usually use a tree structure.  In which each node has some number of slots also two for purposes.  And each slot contains a pointer repeated on down the tree until the final leaf contains the value.  The slot at the very top gives us the length of the list.  When something is added or changed, instead of copying the entire tree, a new pinpointer or set of pointers is added.
      Currently, these are mostly implemented using shallow trees that have 32 slots per node to keep insertion and look up fast.  Lookup itself is performed using bit partitioning, which uses digital as path keys and employs powers of two like 32, for instance, so that bit shifting optimizations can be used in lookup operations, instead of needing divider.  There's a really great write-up from John Nicholas about all of this that's in a ton of detail.  There's a link at the bottom here, and it will be on the slides.  My reference slides at the end.  It's super worth reading.  Probably, like, don't to other sessions.  Just read about persistent data structures.
      But with images of trees dancing in her head, our heroian has led up to a very nice room by the ghosts and put to bed.  She wakes in the middle of the night to discover the ghosts across the reveen are calling her over.
      [Laughter]
      Our heroian creeps out of the castle, it turns out night is way less scary when the ghosts are nice and heads towards the bridge.  They wave at her to cross.  Hypnotized, she walks toward the center of the broken bridge.  Each step lights up an opening paren along the handrail.  And then when she goes to the walkway, the closing parens all light up and the bridge completes.
      She continues across and is soon in the great room at the Clojure script.  The other ghosts explain that the previous castle stole their data structure idea, which is why they installed this magical bridge.
      Here, rather than adapting JavaScript, the code is entirely different.  Even though it's JavaScript that comes out at the end.  So now we can see how on you data structures look in Clojure script.  The interesting thing with this approach is that instead of deciding where to enter the world with immutable data step by step, always immutable by default and instead, data structures can be chosen, for instance, instead of in atom.
      Where it's faster to be immutable and immutable piece by piece, we're more often mindful of which actions are fast and which are slow.
      So, for instance, the ghosts insist use asoc.  It's much faster.  They also note the comparisons are faster too.  In this choice using I'll see instead of equals.  So, for instance, the best baby-sitters are not identical.  They're not the same data structure, but they are equal in the sense that they both contain Stacy and Claudia, clearly, the best baby-sitters.  We also get access to some weird Clojure spells like hard-core structuring what you can have access to the inner contents as well as the objects itself, which you can't do in JavaScript still.  We can have some very elegant pipe lining, that's what's going on with that double arrow macrodown there.  You can pass your data through a pipeline the same way you might chain map calls in JavaScript.  And there's some really nice built in expressions, like, if not, which is one of my personal favorites.
      And our heroian does find this code to be very pretty.  But is it fast?  She sits down and begins her work.  She decides to leave functions that involve close interfacing with the GL API in plane JavaScript, and that way we can limit the interrog to passing data structures once they've been finalized.  This limits the amount of time between data structures, which is a problem you're going to run into any time you're using something that has a custom data structure on top of JavaScript.  At some point, you're going to have to convert through vanilla JavaScript and being mindful of where you decide to do that can be very helpful.
      But how do these new ghost versions work?
      Turns out, the answer's not great.  Tragically.  At 3,000, the immutable version is down to nine or ten frames per second while vanilla is still at 26.  Clojure script, meanwhile, slips between 100 and 1,000.  In fact, for this last one, our heroian had to turn on CPU throttling for the 100 objects view in order to see what was causing problems because one of the interesting things is that when your performance tools use WebGL, and you're trying to do WebGL performance when you break everything, sometimes you don't have access to the tools anymore.
      So that's a case where the CPU throttling really comes in handy.
      And so this is not better; right?  This is worse.  But why?  She looks deeply into the programs and noises that each time things get slow, minor garbage collection is high.  The ghosts look sad and nod.  This time with immutable, it produces so much extra data structures.  The garbage collectors have to clean them up and, in fact, our heroian suspects that it's built on a big pile of garbage data structures.
      And so she had to go to the garbage collectors themselves.  The ghosts float to a window on the opposite side of the room and point.  And there across a plain in what must have been the very edge of the world was a land shrouded in darkness.  This is the land of the garbage collectors.  Her heroian sets off to find the truth.  When she finally reaches the border of the garbage mounds, she comes across this adorable patrol-like woman guarding the crossing.  She can never return if she crosses.  But the woman does offer her a slightly different art running box explaining it has a new approach to running art, and it's called a Safari.
      When our heroian runs her examples on this box, she finds that they are running slightly more smoothly not dropping a frame.  And that's because of rip tied, which is a new algorithm, the garbage collector explains.  So all garbage collectors visit each object in memory and mark whether it's still in use or not.  This can take a long time, relatively speaking, especially if you're discarding thousands of cubes frame by frame.  In this newer version, the marking is done concurrently on a separate thread from that used on the browser.  That means if the garbage collection won't block the browser's operation and cause the frames.  It's also done in parallel, meaning each pass can perceive more quickly.  Rip tied uses generational marking, which the garbage collectors note helps in particular with programs that allocate a lot.  And our heroian's case, for instance, she's been using the spread operator with wild abandon.
      Our heroian is fascinated by the garbage collector's information, but she knows she's reached the end of her trail, and it's time to head home.  This is not the end, though, right now our heroian doesn't know it.  Now she only knows she will return home without a good solution.  No parades, no tales around the fire, no strangers buying her beer at the bar.  It's very tragic.
      And in a few weeks, she's redeemed from her moping.  An old witch of whom she had taken little notice before invites her in and asks her what did happen on her adventure?  Sulking like it's her job, she said all I learned stadium a mistake but being old and very wise, the witch is, like, just tell me your story.  Mistakes are where all the best stories happen.  And together they find out what they really learned.  We can say we've learned immutability biggest limit is probably going to be when you're dealing with a lot of garbage collection.  Which I just discovered all of the problems.  But I did it really cute.
      Without careful attention, our immutable escape hatches in a quickly-changing program is going to change a lot of things to be disposed of immediately.  And this might not matter if you're not doing animations or a slow moment here is bearable.  And so more broadly, we can say that she learned that not all clever adaptations are right for all problems.  For instance, creating virtual trees is a great paradigm and can support models.  Namely one our view is a function of our data.  But if you cannot prune the tree easily, dipping can quickly become slow.  Meanwhile, mutation, which has been on the outs those days as everyone discovers how great FP is, which let us all agree it's super great, mutation, though, is really fast.  It's probably what you need if you're 10,000 objects every frame.  Than the all clever adaptations are right for all problems is a key lesson the witch notes and one which we tend to have to relearn every time we find out about a paradigm we haven't heard of before.
      Next she found out that membranes matter.  Which is to say she had the chance to apply different tools to the same problem and in so doing investigate their primary distinction.  Which is where each place the line between reference and copy, the boundary where one piece of data became two.  And the ramifications of these choices.
      The decision of where to place a membrane, what to expect through an API, what to ask your users to configure, which characteristic will determine downstream capabilities, these are at the core of the choices we make when we build or choose tools, which is to say it matters where we decide to draw our lines.  And so in the case of this adventure, vanilla JavaScript because it mostly defaults to reference allows us to draw the rendering for copy in a small, tight place where we create the virtual tree.  It does have to be done recursively as we noted, but it can be in a small be location.  Immutable JS makes it possible to move the membrane wherever it works best for you.  Though, it mostly represents the opposite, which is making things immutable where you're first making the data and then using internal escape hatches to make multiple mutable data changes to a structure.
      This is a very interesting approach.  I think it's a little bit to the expensive syntax, and it does involve a lot of overhead, always considering how you're deciding to manipulate your data.
      Finally, Clojure script has what I would say an inverted membrane from vanilla JavaScript where immutability can be declared at small points, and this is very interest but comes with a high cost of garbage collection.  And that takes us to this lesson.  Which is to say that limits are inevitable.  Whether the limit be reached at 1,000, 5,000, 100 objects, it exists.  And if speed for 10,000 is what you need, the weird witchy incantations of WebGL are probably already optimized for you.  But a really nice interface can exist for our 100 and 1,000 and depending on what your art is, that might be enough.  Oh, yeah, and what was your art project anyway, asked the witch?  Other than the search.  Here our heroian picks up the test example and shows the old woman.  As they look at it, sort of sludgy, they notice that it has its own charms.  If you look at it just right.  And, though, it wasn't intended to be the best art just kind of a test for some limits, it turned out to be a little bit beautiful after all.  And that's our final lesson.
      Failure is a really great medium.  Z fighting, which is what happens when your 3D objects and matrixcies.  Don't line up.
      And works like slow hot computer by Sam Levine, which is about making your computer fail is art and criticism of capitalism.  It's a really great piece.  There's glitch paintings.  You know, not to mention every novel with abantihero failure can be really compelling too if we explore its limits and outlines.  In the meantime, what's next?  Well, there's always these options.  We can make an art tool with fewer than 100 objects.  We can look into GPU optimizations and seeing the art of getting the most on screens as possible.  Or head back to the fork and pick up that crazy fragment shader path.  But for today, that's it.  Everything in this talk is based on the work of ventures who proceeded me.  There's slides in the PDF, so you can go through and read through and keep the exploration up, and they can have their credit and speaking of credit, I want a shout out Emily Griffin again my illustrator.  She did such a wonderful job, so please check out everything online and thanks so much.
      [Applause]
      
